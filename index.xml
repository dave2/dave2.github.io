<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Loosely Coherent Ramblings</title><link>https://dave2.github.io/</link><description>Recent content on Loosely Coherent Ramblings</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 31 Oct 2022 09:23:10 +1300</lastBuildDate><atom:link href="https://dave2.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Hexagon Update: One Month</title><link>https://dave2.github.io/post/hexagon-update-2022-10-31/</link><pubDate>Mon, 31 Oct 2022 09:23:10 +1300</pubDate><guid>https://dave2.github.io/post/hexagon-update-2022-10-31/</guid><description>&lt;p>Around a month ago, I started writing this silly game and I must
admit I am still surprised it&amp;rsquo;s gotten to the point it has. I expected
that world generation would really be my undoing, and instead it
seems to be going okay.&lt;/p>
&lt;h2 id="then-vs-now">Then vs Now&lt;/h2>
&lt;p>
&lt;figure>
&lt;img src="earliest-screen.jpg" alt="Screenshot of Hexagon World at near the start of development, shows hand-defined world under menu">
&lt;figcaption>28 September 2022&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="one-month.jpg" alt="Screenshot of Hexagon World at one month, show land, water, cities, roads and boat paths">
&lt;figcaption>31 October 2022&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h2 id="current-state">Current State&lt;/h2>
&lt;p>So where are we at now? Well, here&amp;rsquo;s a short list of what was done
in the last month:&lt;/p>
&lt;ul>
&lt;li>Interim camera movement (currently using WASD)&lt;/li>
&lt;li>Hexagon tile placement, along with most of the math to manage
simple tile relationships (like neighbours)&lt;/li>
&lt;li>Tile attributes are not hard-coded, but defined in JSON and
interpreted by the code building the current view&lt;/li>
&lt;li>Tiles are spawned/removed automatically by camera view&lt;/li>
&lt;li>Tiles can have a decoration placed on top, and rules enforced by
attributes in JSON&lt;/li>
&lt;li>Tile decorations can react to roads and push to a different decoration&lt;/li>
&lt;li>Tile models can be normalised for connections to other tiles, generate
the rotation of tiles needed to make all possible combinations&lt;/li>
&lt;li>World Generation:
&lt;ul>
&lt;li>Repeatable generation from a seed&lt;/li>
&lt;li>Biomes (defined but not yet used)&lt;/li>
&lt;li>Terrain (including height)&lt;/li>
&lt;li>Forests&lt;/li>
&lt;li>Cities with walls, generated names, and internal details&lt;/li>
&lt;li>Transport built between cities that respect terrain (roads for land,
boat paths for water, and transition details between land/water),
terrain has costs for being traversed depending on tile and height,
avoidance of tiles or tile decorations for transport paths&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Saving and loading game state including map&lt;/li>
&lt;li>Managing save game slots&lt;/li>
&lt;li>Global setting saving and loading (eg, music volume)&lt;/li>
&lt;/ul>
&lt;p>Yeah I really am surprised all that got done, and works.&lt;/p>
&lt;h2 id="unrealistic-future-plans">Unrealistic Future Plans&lt;/h2>
&lt;p>The next month or so I want to focus on two things:&lt;/p>
&lt;ul>
&lt;li>Finish world generation
&lt;ul>
&lt;li>Build &amp;ldquo;counties&amp;rdquo; for difficulty level&lt;/li>
&lt;li>Add more POIs than just cities (like, villages, mines, farms,
lumber yards, mills, and watch towers)&lt;/li>
&lt;li>Add a little more detailing to grass than just bulk forest&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Movement
&lt;ul>
&lt;li>Visual representation of where the player is&lt;/li>
&lt;li>Show navigation rule application&lt;/li>
&lt;li>Allow player to move around the map&lt;/li>
&lt;li>&amp;ldquo;Fog of War&amp;rdquo;-like discovery of the map&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Let&amp;rsquo;s see how this all goes!&lt;/p></description></item><item><title>Hexagon Update: 25 Oct 2022</title><link>https://dave2.github.io/post/hexagon-update-2022-10-25/</link><pubDate>Tue, 25 Oct 2022 09:25:22 +1300</pubDate><guid>https://dave2.github.io/post/hexagon-update-2022-10-25/</guid><description>&lt;p>Lots since the last update, lets dive into it.&lt;/p>
&lt;h2 id="refactoring-outcome">Refactoring Outcome&lt;/h2>
&lt;p>Refactoring all the road generation to use tile variants instead of
laying a separate prefab on top was a Huge Success and was definitely
the right approach.&lt;/p>
&lt;p>Baking the roads into the tile set took a while but it resulted in
a much nicer implementation internally, as I took the chance to also
drop object pooling.&lt;/p>
&lt;p>An optimization I had done very early on was to push 3D tiles into a
pool of pre-instantiated objects and pull them into the world as
needed. This is fairly useful in most game engines, but actually in
Godot it turns out it has no useful performance gain at all.&lt;/p>
&lt;p>In Godot, the cost of &lt;code>.instantiate()&lt;/code> is basically nothing and you
get a much cleaner code path without involving your own object pool.
You can just create objects and then &lt;code>.queue_free()&lt;/code> them when done.
The name of that function hints at what is going on under the hood,
and something I hadn&amp;rsquo;t really noticed until I did the refactor.&lt;/p>
&lt;p>So long as you&amp;rsquo;ve already loaded the resource, the cost of spawning
many new ones at once is as low as all the work needed to maintain
the object pool. Having an object pool adds huge complexity (mostly
on the freeing side, you can&amp;rsquo;t just free the object, you need to
&amp;ldquo;hand back&amp;rdquo; the object to the pool). Given all the extra complexity
with no performance gain, it was a good thing to remove it entirely
and write more simple code.&lt;/p>
&lt;h2 id="stalling">Stalling&lt;/h2>
&lt;p>Having refactored all code around the map view and in turn the way
we load tile type information, it was time to revisit world generation,
but specifically about both how slow it ran and the lack of feedback.&lt;/p>
&lt;p>Providing feedback to the user is really important. If you&amp;rsquo;re given
a blank screen with no visible activity, the instinct is the game
has crashed or is otherwise misbehaving, and to kill it. It&amp;rsquo;s
important while doing heavy work to show work being done, and ideally
some indication about the progress of that work.&lt;/p>
&lt;p>Okay, no worries, Godot has progress bars and text I can display for
such things. But despite sending updates to the progress bars and
text, nothing rendered until it was all done.&lt;/p>
&lt;p>The immediate approach I took was to slice off the world generation
into a thread and then just wait around for that to complete. This
sort of worked and then I changed things and it didn&amp;rsquo;t, and because
I&amp;rsquo;m not the smartest person I couldn&amp;rsquo;t remember what was actually
changed which made any difference.&lt;/p>
&lt;p>Godot supports threads, and all the supporting elements needed to make
threads word (like mutexes and semaphores). Alas, adding all these
in various places didn&amp;rsquo;t make the code behave any better. In one
part of the code, we&amp;rsquo;d test if the thread was running and it would
always return false, while the output showed the thread &lt;em>clearly&lt;/em>
still running and spamming the log with messages.&lt;/p>
&lt;p>It also didn&amp;rsquo;t help that it started to look like sometimes if you
called functions they actually somehow caused all the visual rendering
to stall even if that function should have been in a thread.. right?&lt;/p>
&lt;p>Two days later, I now have a better understanding of both Godot&amp;rsquo;s
main loop and most of the downsides of threads. Not a fun two days.&lt;/p>
&lt;p>One thing I had forgotten is by and large games are single-threaded.
They might offload certain low level functions to a thread, like
audio playing or physics, but many games (and game engines) are
single threaded because there are less complications about data
access and synchronization than a multi-threaded game or engine.&lt;/p>
&lt;p>In Godot&amp;rsquo;s case, rendering and &lt;code>_ready()&lt;/code> in a script share a thread,
so if you block in &lt;code>_ready()&lt;/code> then rendering ain&amp;rsquo;t going to work.
But, I had &amp;ldquo;solved&amp;rdquo; this with making sure world gen was on a thread.&lt;/p>
&lt;p>Well, sort of. Yes, some of it was on a thread, but not all of it,
and it was hard to identify what was actually executing where. A lot
of print-as-debug was added with every line including the output of
&lt;code>OS.get_thread_caller_id&lt;/code> to show where this was really taking place.&lt;/p>
&lt;p>What I found was it looks like singletons in Godot always execute on
the main thread, and the way to avoid this is ensure any functions
you call are on separate objects in your thread. Okay, refactor
around that a bit (the calls into the world map singleton are fast,
so we&amp;rsquo;ll ignore they run in the main thread, but it meant world gen
had to be separated from the singleton).&lt;/p>
&lt;p>Still, we had problems, threads were being reported to the main
code as finished when the logs were full of signs they were running.
Getting to the bottom of this I think came down to pure luck and
writing a separate set of tests in a different Godot project.&lt;/p>
&lt;p>The test case I wrote looked something like the following. Note in
this example we have a script on a node called &lt;code>SimpleProgressBar&lt;/code>
which updates different elements, like upper and lower text messages
as well as the bar itself.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>var progress_bar : Node
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var m : Mutex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>func _ready():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># we&amp;#39;ll use a progress bar for visuals&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> progress_bar &lt;span style="color:#f92672">=&lt;/span> get_node(&lt;span style="color:#e6db74">&amp;#34;SimpleProgressBar&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># we&amp;#39;ll use this to protect our access&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m &lt;span style="color:#f92672">=&lt;/span> Mutex&lt;span style="color:#f92672">.&lt;/span>new()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># start the long work thread&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> var t &lt;span style="color:#f92672">=&lt;/span> Thread&lt;span style="color:#f92672">.&lt;/span>new()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t&lt;span style="color:#f92672">.&lt;/span>start(Callable(self,&lt;span style="color:#e6db74">&amp;#34;_long_work_thread&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">100&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># update the progress bar too!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m&lt;span style="color:#f92672">.&lt;/span>lock()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> progress_bar&lt;span style="color:#f92672">.&lt;/span>set_progress(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m&lt;span style="color:#f92672">.&lt;/span>unlock()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> get_tree()&lt;span style="color:#f92672">.&lt;/span>create_timer(&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>timeout
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># wait for the thread to exist&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> t&lt;span style="color:#f92672">.&lt;/span>is_alive():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> get_tree()&lt;span style="color:#f92672">.&lt;/span>create_timer(&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>timeout
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># clean up thread (normally blocks unless thread is dead)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t&lt;span style="color:#f92672">.&lt;/span>wait_until_finished()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>func _long_work_thread():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">100&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># update the progress bar, ensuring no-one else is&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m&lt;span style="color:#f92672">.&lt;/span>lock()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> progress_bar&lt;span style="color:#f92672">.&lt;/span>set_lower_text(&lt;span style="color:#e6db74">&amp;#34;Long process step &lt;/span>&lt;span style="color:#e6db74">%d&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">%&lt;/span> i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m&lt;span style="color:#f92672">.&lt;/span>unlock()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># simulate a long process&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OS&lt;span style="color:#f92672">.&lt;/span>delay_msec(&lt;span style="color:#ae81ff">5000&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Okay, so the test case worked, even though I was sure I was doing
the same thing in my game code. The long work thread continues to
update the progress bar and this visually updates, and the code
in &lt;code>_ready()&lt;/code> waits for the long work thread to complete.
It turns out, I wasn&amp;rsquo;t doing this actually, and the detail is interesting.&lt;/p>
&lt;p>The use of &lt;code>await&lt;/code> in &lt;code>_ready()&lt;/code> is because we don&amp;rsquo;t want to block,
we know that we can&amp;rsquo;t call &lt;code>OS.delay_msec()&lt;/code> because it would block
and then rendering would stop. In the thread, we &lt;em>can&lt;/em> just block
(after all, that&amp;rsquo;s the point of the thread), so we call &lt;code>OS.delay_msec()&lt;/code>.&lt;/p>
&lt;p>Going back over my game code, surely it doesn&amp;rsquo;t matter in a thread
if we block or not, the thread is separate and we can do what we
like. Oh, no, we definitely can&amp;rsquo;t.&lt;/p>
&lt;p>Let&amp;rsquo;s use a non-blocking delay instead in the long work thread, change
&lt;code>OS.delay_msec(5000)&lt;/code> to &lt;code>await get_tree().create_timer(5).timeout&lt;/code>
which is the same 5 second delay. Suddenly now the main code in
&lt;code>_ready&lt;/code> doesn&amp;rsquo;t wait for the thread to finish, it just plows through
having been told from the result of &lt;code>t.is_alive()&lt;/code> that the thread
is dead.&lt;/p>
&lt;p>It appears that you &lt;em>cannot&lt;/em> call &lt;code>await&lt;/code> in a thread other than the
main thread. For whatever reason, the thread is lost and forgotten
and you can&amp;rsquo;t get back to it. It is not the case that creating a
thread gives you the same properties as the main thread &lt;em>at all&lt;/em>.&lt;/p>
&lt;p>The reason this tripped me up is that I was also doing some fancy
fades using tweens to the progress bar. The common way to write
this (and comes up in all the searches BTW) is:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>var tween &lt;span style="color:#f92672">=&lt;/span> create_tween()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tween&lt;span style="color:#f92672">.&lt;/span>tween_property(progress_bar, &lt;span style="color:#e6db74">&amp;#34;modulate:a&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">1.0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">await&lt;/span> t&lt;span style="color:#f92672">.&lt;/span>finished
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So naturally, in my thread for doing long work, it started with
that exact fragment. And then the thread blew up.&lt;/p>
&lt;p>In fact, in the main loop we can do that, but we &lt;em>must&lt;/em> block if
we want to do that in a thread, and it becomes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>var tween &lt;span style="color:#f92672">=&lt;/span> create_tween()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tween&lt;span style="color:#f92672">.&lt;/span>tween_property(progress_bar, &lt;span style="color:#e6db74">&amp;#34;modulate:a&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">1.0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> tween&lt;span style="color:#f92672">.&lt;/span>is_running():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OS&lt;span style="color:#f92672">.&lt;/span>delay_msec(&lt;span style="color:#ae81ff">100&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Annoyingly, this also still causes rendering issues, but mostly
it seems to be because &lt;code>OS.delay_msec()&lt;/code> might just busy-loop and
so it starves something else of cycles, so you get stuttering and
uneven tweens.&lt;/p>
&lt;p>The alternative to a thread for long work is our friend &lt;code>await&lt;/code> and
littering your long work with lots of calls to &lt;code>await get_tree().process_frame&lt;/code>
which will gracefully leave to allow rendering to continue for a whole
frame, and then come back. This is pretty much how a single-threaded
game should be doing things, but it certainly feels rough to write.&lt;/p>
&lt;p>Anyway, that&amp;rsquo;s two days I won&amp;rsquo;t get back.&lt;/p>
&lt;p>I&amp;rsquo;m unsure if I&amp;rsquo;ll revert out of threads for things like world gen,
or leave it there. Now it has no problems with unexplained &amp;ldquo;death&amp;rdquo;
it works so I&amp;rsquo;m tempted not to touch that whole space for a while.&lt;/p>
&lt;p>Performance was also problematic for generating the world (even in
a nice thread). There were quite a few cases where I was using
a &lt;code>Dictionary&lt;/code> for performance and then throwing that all away by
forcing GDscript to iterate over an &lt;code>Array&lt;/code>, which is a lot slower.&lt;/p>
&lt;p>For example, here&amp;rsquo;s a few of ways of testing if we have something:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>var big_thing : Dictionary()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> big_thing&lt;span style="color:#f92672">.&lt;/span>has(&lt;span style="color:#e6db74">&amp;#34;key&amp;#34;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#e6db74">&amp;#34;key&amp;#34;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> big_thing:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#e6db74">&amp;#34;key&amp;#34;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> big_thing&lt;span style="color:#f92672">.&lt;/span>keys()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The first is obviously using the dictionary correctly. The second and
third I thought were the same, because of the &lt;code>in&lt;/code> operator. This is
not the case: using &lt;code>in&lt;/code> with a &lt;code>Dictionary&lt;/code> is functionally the same
as calling &lt;code>.has()&lt;/code> on it, while using &lt;code>in&lt;/code> with the result of &lt;code>.keys()&lt;/code>
of the &lt;code>Dictionary&lt;/code> produces an &lt;code>Array&lt;/code> and then uses the &lt;code>in&lt;/code> operator
on it which is really really slow.&lt;/p>
&lt;p>I&amp;rsquo;ve been mixing all three types without much care, and it actually
matters a lot. I still randomly pick between &lt;code>x.has(key)&lt;/code> and &lt;code>key in x&lt;/code>
which isn&amp;rsquo;t so good, but for now at least they both don&amp;rsquo;t suck.&lt;/p>
&lt;p>This alone was responsible for a large amount of lost time in world
generation.&lt;/p>
&lt;h2 id="saving-and-loading">Saving and Loading&lt;/h2>
&lt;p>After the fun with threads, I got on with actually useful progress
(ha ha) and implemented saving and loading the game state. This
is mostly easy, and apart from not clearing out some state when
loading, it just works.&lt;/p>
&lt;p>Save games are packed binary files, because serialization to say
JSON is kind of annoying. Lots of types you &lt;em>have&lt;/em> to munge and
can&amp;rsquo;t just call &lt;code>JSON.stringify()&lt;/code> on a wodge of data. Instead
you have to pick out and transform some things to strings before
trying to throw them into JSON.&lt;/p>
&lt;p>It&amp;rsquo;s not that &lt;code>stringify()&lt;/code> can&amp;rsquo;t convert some types to strings,
it does that just fine. It&amp;rsquo;s that the inverse function, &lt;code>parse()&lt;/code>
doesn&amp;rsquo;t understand how to reverse &lt;code>stringify()&lt;/code> for all cases.&lt;/p>
&lt;p>Take a &lt;code>Vector2&lt;/code>, the string version is something like &lt;code>&amp;quot;(1.0, 2.0)&amp;quot;&lt;/code>,
which is just fine, it&amp;rsquo;s what &lt;code>JSON.stringify()&lt;/code> produces, it&amp;rsquo;s valid
JSON so all good. However, &lt;code>parse()&lt;/code> just sees that as a string and
gives you back .. a string. Fair enough, it &lt;strong>is&lt;/strong> a string, but it&amp;rsquo;s a
string you &amp;ndash; Mr JSON class &amp;ndash; put there. You want to give me back
what I put into you? &amp;ldquo;Hell no&amp;rdquo; says Mr JSON class.&lt;/p>
&lt;p>Thankfully, compared to the threading stuff, that&amp;rsquo;s easy to deal with.
Don&amp;rsquo;t use JSON for save games.&lt;/p>
&lt;p>(Aside: Not that binary is free of any quirks either. The binary
store/load functions have &lt;code>.store_string()&lt;/code> which most definitely
does not &amp;ldquo;store&amp;rdquo; a string like every other function with &amp;ldquo;store&amp;rdquo;
in the name. There is no &lt;code>.get_string()&lt;/code> to match it, while every
other &amp;ldquo;store&amp;rdquo; function has a matching &amp;ldquo;get&amp;rdquo;. It wasn&amp;rsquo;t immediately
obvious if you want to store/load a string you really need to
use &lt;code>.store_pascal_string()&lt;/code> which has a matching &amp;ldquo;get&amp;rdquo; and
is a great throwback to a long forgotten language.)&lt;/p>
&lt;h2 id="next-up">Next up&lt;/h2>
&lt;p>Because I can&amp;rsquo;t leave well enough alone, I&amp;rsquo;m exploring a different
tile set to the one currently being used. It has some nice features,
like hexagons are more obviously visible, and a lot of interesting
decorations for tiles.&lt;/p>
&lt;p>While playing around with a different tile set, it&amp;rsquo;s also become
clear I am not handling materials on tiles in a way that makes it
a bit easier for me to tweak the tile colouring and surface. So
we&amp;rsquo;ll also be fixing that for the tile sets as well.&lt;/p></description></item><item><title>Hexagon Update: Oh no</title><link>https://dave2.github.io/post/hexagon-update-2022-10-21/</link><pubDate>Fri, 21 Oct 2022 15:14:39 +1300</pubDate><guid>https://dave2.github.io/post/hexagon-update-2022-10-21/</guid><description>&lt;p>
&lt;img src="this-is-fine.jpg" alt="This is fine">
&lt;/p>
&lt;p>So I am now deep in the refactor well, and I&amp;rsquo;m pretty sure I can
eventually get myself out, but right now everything is broken
until I get to the bottom of the well, and start digging my way
up.&lt;/p>
&lt;p>What triggered this was supporting roads. In the picture I posted
on &lt;a href="https://dave2.github.io/post/hexagon-update-2022-10-18/" >the last update&lt;/a> there
was a lovely road going through the gap in the forest. But there
wasn&amp;rsquo;t a gap there really.&lt;/p>
&lt;p>The road pieces can be spawned on top of any tile, and that&amp;rsquo;s how
it looks like it could be used, but then you can&amp;rsquo;t really use them
on any tile which has other things on it. That is, it works on
the plain flat tiles, but not say a forest tile. On a forest tile,
you get a look of a road which has trees all over it.&lt;/p>
&lt;p>To work around that did a quick hack to just force the tile to one
of the plain flat ones when a road gets created on a tile that isn&amp;rsquo;t
so well designed for roads. Thus, the picture of the road going
through the gap in forest is really the road mowing down all the
forest tiles in its way on the shortest bit of forest to cross.&lt;/p>
&lt;p>I didn&amp;rsquo;t really like that, a road piece that neatly weaved through
a forest closely would be nicer. And nicer becomes &amp;ldquo;let&amp;rsquo;s refactor
the entire world&amp;rdquo;.&lt;/p>
&lt;p>The upside is the tiles will look better when done, and at the same
time I have half an idea of how to manage water traversal as well.
It&amp;rsquo;ll involve less objects in the world as well.&lt;/p>
&lt;p>I have progressively integrated the road pieces, in some cases
recolouring them, into the base tiles and adjusted the decorations
on those tiles to allow the road piece to fit in, and then collected
it all into a new tile - original base tile plus road piece - so
they can be spawned at once.&lt;/p>
&lt;p>This is mostly some work in Blender, since the tiles are all easily
messed with in Blender. Using Blender falls into that slightly annoying
tool space where &lt;a href="https://www.kicad.org/" rel="noopener" target="_blank">KiCAD&lt;/a> lives in my head as well.
It&amp;rsquo;s one of those tools where knowing the keyboard actions &lt;em>really&lt;/em> matters
and without that you will struggle to do anything quickly at all.&lt;/p>
&lt;p>Anyway, that bit is done, I have many more tiles than I had before,
and the ugly code and metadata reorganisation has begun.&lt;/p>
&lt;p>I&amp;rsquo;ll surface in a few days to report why I shouldn&amp;rsquo;t have done this.&lt;/p></description></item><item><title>Hexagon Update: Roads .. again</title><link>https://dave2.github.io/post/hexagon-update-2022-10-18/</link><pubDate>Tue, 18 Oct 2022 15:47:47 +1300</pubDate><guid>https://dave2.github.io/post/hexagon-update-2022-10-18/</guid><description>&lt;p>Well, it wouldn&amp;rsquo;t be my code development if any design pattern lasted
longer than four hours! In fact, in the &lt;a href="https://dave2.github.io/post/hexagon-update-2022-10-17/" >previous post&lt;/a>
it omits the details this was actually the second pass, where we
stored masks in the tile data directly, rather than in a different
set of dictionaries.&lt;/p>
&lt;p>But, before tackling changing everything again, I did get to a better
place about how to draw roads on the map. Not the display part now,
the actual &amp;ldquo;draw road from A to B&amp;rdquo; including all the steps needed
to join them.&lt;/p>
&lt;p>Pathfinding is a well trodden area in game design. There&amp;rsquo;s a bunch of
methods, but the &lt;a href="https://en.wikipedia.org/wiki/A*_search_algorithm" rel="noopener" target="_blank">A* algorithm&lt;/a> fits my needs pretty well. This involves
building a graph of nodes connected by edges, and assigning weights or
costs or whatever you want to call it to traversing the node or edge.&lt;/p>
&lt;p>I was thinking I might have to build A* myself in GDscript but what&amp;rsquo;s
this? Oh, Godot already includes A* classes to do all the work for me.
Well, most of the work anyway, the traversal bit anyway. In Godot 4
we actually get three different versions of A*, mostly separated by
the node elements.&lt;/p>
&lt;p>Because we&amp;rsquo;re doing pathfinding on a 2D plane&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> we&amp;rsquo;ll use the &lt;code>AStar2D&lt;/code>
class for our pathfinding. This provides two virtual methods we will
need to replace, &lt;code>_compute_cost()&lt;/code> and &lt;code>_estimate_cost()&lt;/code> which given
two points returns the exact or lower-bound cost of the path between
the two points.&lt;/p>
&lt;p>We have to overide those as we want our costs based on axial coordinate
distances, not cartesian coordinates for the tiles themselves. And
the &lt;code>AStar2D&lt;/code> wants nodes with cartesian coordinates (specifically, it
expects &lt;code>Vector2&lt;/code> coordinates). I should point out, this is noted in
the Red Blog Games Hexagon Guide about &lt;a href="https://www.redblobgames.com/grids/hexagons/#pathfinding" rel="noopener" target="_blank">Pathfinding&lt;/a>,
and is not something I&amp;rsquo;ve pulled out of skill or knowledge myself!&lt;/p>
&lt;p>As we have a grid of tiles (albeit a hexagon grid), we&amp;rsquo;ll just throw
a graph containing a node for every tile, and connections from each
node to all neighbours that meet appropriate criteria (mostly, can put
a road on it!)&lt;/p>
&lt;p>At this point, the current implementation and the one I want to move
to changes a bit. I&amp;rsquo;ve added costs to the metadata about tile types,
as we&amp;rsquo;re applying something simple as a policy: tiles like grass
are easy to move on, tiles like forests and mountains are harder but
not impossible, and water should be impossible .. for now.&lt;/p>
&lt;p>I am making forests and mountains hard but not impossible to produce
roads that tend to avoid these obstacles rather than plow through them,
but will plow through them when there&amp;rsquo;s little choice but to make a
very large detour around them. I think this will produce a pleasing
balance between direct straight line roads and roads which have nice
natural curves and meandering.&lt;/p>
&lt;p>As it happens, building the graph the &lt;code>AStar2D&lt;/code> class needs is
remarkably easy. When we create a new tile (using the badly named
&lt;code>set_tile()&lt;/code>) we generate the point index the graph wants and store
it with the tile. Then in &lt;code>update_tile()&lt;/code> (which gets called either
directly or by &lt;code>set_tile()&lt;/code>) we add/update the point in the graph
with the cost of that type of tile. This means when we change tiles
we also update the costs in the graph of the tile.&lt;/p>
&lt;p>However, we also need to maintain the graph, so we do this in &lt;code>update_tile()&lt;/code>
as well. We also need to remove the point if the tile is no longer
navigable, and connect or disconnect points in the graph as well. For
connecting and disconnecting points, we walk our neighbours and check
if they are appropriate to move into, and then add these appropriate
connections.&lt;/p>
&lt;p>In psuedo-code, for each tile we update it looks like:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-nohighlight" data-lang="nohighlight">if updating tile:
if tile_type is allowed road:
add/update this point in graph
for each neighbour:
if neighbour is allowed road:
add connection between this tile and neighbour tile
else:
remove connection between this tile and neighbour tile
else:
for each neighbour:
remove connection between this tile and neighbour tile
remove point from graph&lt;/code>&lt;/pre>
&lt;p>Once we have the graph with nodes, we can ask it for the path between
two points. Because the &lt;code>AStar2D&lt;/code> class expects point indexes, there&amp;rsquo;s
a bunch of translation back and forth between axial coordinates of
tiles and the point index. But, that&amp;rsquo;s fairly quick and thus we have
roads which look more natural:&lt;/p>
&lt;p>
&lt;img src="its-a-road.jpg" alt="A generated road on the Hexmap">
&lt;/p>
&lt;p>I said there were things I wanted to change, and in writing this down
plus the development issues, I think it will be reworked a bit very
shortly.&lt;/p>
&lt;p>The first problem is that as road pieces are expected to sit on a
tile, they clash with some tiles. Forests, for example, don&amp;rsquo;t really
look so good with a road going through them because the trees on the
tile look like they&amp;rsquo;re on the road. To work around that, the
current version just forces the tile to grass if it was forest before.&lt;/p>
&lt;p>The other problem is water. Water is currently not allowed for
traversal. It makes no sense, it&amp;rsquo;s a road, not a boat. How this
is going to be managed is uncertain, but it&amp;rsquo;ll have to be some
how. The map may end up with a slice of water dividing it in two
and without any way of generating a road between the two sides.&lt;/p>
&lt;p>But these are problems for another day.&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>The world is a flat plane even if we were to jazz it up a bit
with tiles at different heights. That is, the player can&amp;rsquo;t decide
to go up or down within a tile, they can only go to whatever height
the tile is. So all our positions are 2D, thus navigation is on a
2D plane.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Hexagon Update: Roads</title><link>https://dave2.github.io/post/hexagon-update-2022-10-17/</link><pubDate>Mon, 17 Oct 2022 11:38:22 +1300</pubDate><guid>https://dave2.github.io/post/hexagon-update-2022-10-17/</guid><description>&lt;p>As I mentioned in &lt;a href="https://dave2.github.io/post/hexagon-update-2022-10-12/" >some previous update&lt;/a>
I have been avoiding roads, although I have some theories on how to
make these work.&lt;/p>
&lt;p>The first part of this however is just making roads appear in the
game world. The generation of roads is a bit pointless if I can&amp;rsquo;t
see them. Also, I expect I&amp;rsquo;ll need to do extensive debugging on road generation
and so I&amp;rsquo;ll also need to see them.&lt;/p>
&lt;p>The tileset I&amp;rsquo;m using&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> has roads as separate models to be added to
the base tiles. The models cover all possible exit positions and
combinations, although they have been normalised so some combinations
and positions require rotating the model.&lt;/p>
&lt;p>
&lt;img src="preview-kenney.png" alt="Preview of Kenney.nl&amp;amp;rsquo;s Hexagon Tile Set">
&lt;/p>
&lt;p>You can see the road tiles towards the bottom left corner of the
image above (taken from Kenney.nl&amp;rsquo;s website).&lt;/p>
&lt;p>For all of the tiles I&amp;rsquo;m using, I load these into the game based on
some metadata about the tile, using a simple JSON file containing a
list of the tiles and their metadata. For example, on the main tile
set I have a metadata index containing:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;water&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;prefab_file&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Tiles/water.glb&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;tags&amp;#34;&lt;/span>: [ &lt;span style="color:#e6db74">&amp;#34;water&amp;#34;&lt;/span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;grass&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;prefab_file&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Tiles/grass.glb&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;tags&amp;#34;&lt;/span>: [ &lt;span style="color:#e6db74">&amp;#34;grass&amp;#34;&lt;/span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>(Aside: we actually read the metadata first and call &lt;code>load()&lt;/code> on the
&lt;code>prefab_file&lt;/code> specified here, which gives us scenes to instance into
the world. Everything is loaded into a &lt;code>Dictionary&lt;/code> for easy access.)&lt;/p>
&lt;p>The same approach is taken with road tiles, where we annotate what
exits a given road piece has:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;exits&amp;#34;&lt;/span>: [ &lt;span style="color:#e6db74">&amp;#34;right&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;left&amp;#34;&lt;/span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;prefab_file&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Roads/path_straight.glb&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;exits&amp;#34;&lt;/span>: [ &lt;span style="color:#e6db74">&amp;#34;right&amp;#34;&lt;/span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;prefab_file&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Roads/path_start.glb&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>As mentioned above, each road piece needs to be rotated to produce
all of the possible combinations. The &lt;code>path_straight.glb&lt;/code> piece has
two other rotations available, 60 degrees should give us exits of
&lt;code>[ &amp;quot;up_right&amp;quot;, &amp;quot;down_left&amp;quot; ]&lt;/code>, and 120 should give us &lt;code>[ &amp;quot;down_right&amp;quot;, &amp;quot;up_left&amp;quot; ]&lt;/code>. (Probably, I haven&amp;rsquo;t checked this is correct!)&lt;/p>
&lt;p>In the first pass of this code, I just wrote out the combinations by
hand, adding a &lt;code>&amp;quot;rotation&amp;quot;&lt;/code> field to the metadata. But I quickly found
this was cumbersome, more so when I got the exits for a given rotation
wrong (usually 0 degrees, so everything from there was wrong!).
Instead, we produce all of the other possible exit positions for a
road piece by iterating over the six different possible rotations and
rotating the exits at the same time.&lt;/p>
&lt;p>At this point, it&amp;rsquo;s useful to talk about how I resolve a tile having
a specific list of exits to a road piece. We need to ignore the order
the exits were provided in, and we need a fast way to look it up.&lt;/p>
&lt;p>The naive implementation would be to stick all the exit combinations
into an array that points to the tile/rotation needed. Then we walk over
every element in the array of combinations, and then on each combination
(itself an array) we compare it to the array of exits we have.&lt;/p>
&lt;p>This is slow, we&amp;rsquo;re walking all possible combinations, and then also
doing a bunch of array walks and then string compares to compare the
exit arrays. Now, maybe this is premature, but there are faster
ways to do this.&lt;/p>
&lt;p>Instead of storing the possible exits as an array of strings, we
convert them to a bitfield. This has a few advantages:&lt;/p>
&lt;ul>
&lt;li>It reduces the exits to a fixed order, regardless of how they
appear in the metadata&lt;/li>
&lt;li>Bitfields are trivial to compare, they end up just as an &lt;code>int&lt;/code>&lt;/li>
&lt;li>Using an &lt;code>int&lt;/code> as a &lt;code>Dictionary&lt;/code> key is fast and reliable&lt;/li>
&lt;li>Rotating the exits is very easy in a bitfield&lt;/li>
&lt;/ul>
&lt;p>Now some of my younger readers will be wondering why on earth I would
go deep into integer math to do this. Well, my programming roots
include a great deal of C (that&amp;rsquo;s C, not C++, not C#) on microcontrollers,
and that space is all about bitfields. And one thing you learn quickly
in that space is when you have very few cycles, bitfields are very
efficient at solving a bunch of problems.&lt;/p>
&lt;p>During import of the road pieces, we convert the exits array for a
piece into a bitfield. We do this by assigning a bit to each exit,
and the order of the bits corospond to going around the possible
rotations. In sort of psuedocode, we do this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>str_to_mask &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;right&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0x1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;up_right&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0x2&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;up_left&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0x4&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;left&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0x8&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;down_left&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0x10&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;down_right&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0x20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>function exits_to_mask(exit_array) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mask &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> exit &lt;span style="color:#f92672">in&lt;/span> exit_array:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mask &lt;span style="color:#f92672">=&lt;/span> mask &lt;span style="color:#f92672">|&lt;/span> dirs_to_mask[exit]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> mask&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>The magic numbers are just the hexadecimal value of each bit being set
(and only that bit).&lt;/p>
&lt;p>When stashing the road tile, we then use the mask for the key in the
&lt;code>Dictionary&lt;/code>, which will be a trivial lookup. (Aside: nearly $O(1)$ if you
really want to know.)&lt;/p>
&lt;p>I said above that rotation is easy as well. If we&amp;rsquo;ve got an array of
strings, we can&amp;rsquo;t just move the array contents around, we have to map
each exit to the exit rotated one step around. The map is not slow
itself (we can just have another lookup table), but in addition to all
the string comparisons in the lookup table we need to walk all the
exit array members.&lt;/p>
&lt;p>Instead, with the bitfield approach, we can rely on bit-shift
operations to do the rotation, with a small bit of work to manage
roll-over. Bit-shifting is often implemented in pure hardware, so
it is reasonably efficient. Rotating the exit list each item is then just:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>function rotate_exits(mask) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># shift all the exits along&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mask &lt;span style="color:#f92672">=&lt;/span> mask &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># pass the rollover bit to the bottom&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mask &lt;span style="color:#f92672">=&lt;/span> mask &lt;span style="color:#f92672">|&lt;/span> (mask &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span> &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># only keep the bits we&amp;#39;re interested in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mask &lt;span style="color:#f92672">=&lt;/span> mask &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0x3f&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># and return it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> mask&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>(Aside: most calculator apps will have a programmer mode that includes
bit-shift and logical operations, which will show why this works.)&lt;/p>
&lt;p>Given this, it&amp;rsquo;s fast to generate all the other road exit combinations
for a given road piece, and to look up what piece we need for any
combination.&lt;/p>
&lt;p>For storage of road information, we mark tiles as having a road, and
store the bitfield of exits. Adding a new road exit is purely
doing a bit-wise OR on that exit in the tile. We also need to adjust
the neighbour tile to reflect the connection back, but this is also
a bit-wise OR.&lt;/p>
&lt;p>This reduces our display effort to something very easy, just pull the
road bitfield, look up that value in the index of all road pieces
that are index by bitfield, and spawn the object in the correct place
and rotation.&lt;/p>
&lt;p>Easy!&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a href="https://kenney.nl/assets/hexagon-kit" rel="noopener" target="_blank">Kenney.nl Hexagon Kit&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Hexagon Game Update: The Past</title><link>https://dave2.github.io/post/hexagon-update-2022-10-13/</link><pubDate>Thu, 13 Oct 2022 12:29:46 +1300</pubDate><guid>https://dave2.github.io/post/hexagon-update-2022-10-13/</guid><description>&lt;p>I realised that since I started writing this silly wee game I actually
haven&amp;rsquo;t written down any of the initial thoughts about how this was
goign to work, and since I&amp;rsquo;ve only just resurrected writing a blog
after I&amp;rsquo;d already started writing the game there&amp;rsquo;s no history here
either.&lt;/p>
&lt;p>Right, let&amp;rsquo;s see about writing some of those thoughts down.&lt;/p>
&lt;h2 id="hexagon-tiles">Hexagon tiles&lt;/h2>
&lt;p>I&amp;rsquo;m implementing a classical RPG and hexagon tiles are pretty common
for maps in that context. Square maps are also an option, but I feel
like they lend themselves better to worlds where you and the party
are in fine-definition worlds, where hexagons are better at
coarse-definition worlds.&lt;/p>
&lt;p>So for example, in a fine-definition world a city or a village
is a large number of tiles, you have the city&amp;rsquo;s streets to actually
navigate around etc. In a coarse-definition world the city is one
tile, possibly with some visual sugar around that, but internal
city views are a bit more menu-like and less navigated using tiles.&lt;/p>
&lt;p>This does also make some types of generation of the world a bit
easier, because we really only looking at high-level detail and
that has a lot fewer elements to try to model. Cities are just a
single world position and not a complex map of tiles within the world.&lt;/p>
&lt;p>That said, there&amp;rsquo;s nothing stopping me from implementing a nested
world approach - where entering a city essentially creates a new
hexagon map at a finer level of detail - so we&amp;rsquo;re not really closing
ourselves off on doing that level of detail. It would always be a
scene switch to do it, however.&lt;/p>
&lt;p>Since I&amp;rsquo;m pretty rubbish at art, I&amp;rsquo;m leaning into &lt;a href="https://kenney.nl/assets/" rel="noopener" target="_blank">Kenney&amp;amp;rsquo;s Assets&lt;/a>
which include a &lt;a href="https://kenney.nl/assets/hexagon-kit" rel="noopener" target="_blank">Hexagon Tile Kit&lt;/a>.
So we have enough art to do world generation and some idea what the
tile set &lt;em>should&lt;/em> be able to do, if I can write the supporting code.
If you have an interest in game dev but not much ability in art, then
you really should look at Kenney&amp;rsquo;s work as it&amp;rsquo;s high quality and
available under very generous license terms.&lt;/p>
&lt;p>The tile set is flexible enough to be coarse or fine-definition, for
the most part. There&amp;rsquo;s some gaps here and there but for this game in
this state the gaps are just small workarounds.&lt;/p>
&lt;h2 id="hexagon-math">Hexagon math&lt;/h2>
&lt;p>Having a set of actual 3D tiles is all very well but you have to
position them. The positioning is
some very well documented math, the resource I used is &lt;a href="https://www.redblobgames.com/grids/hexagons/" rel="noopener" target="_blank">Red Blob Games Hexagonal Grids&lt;/a>
which is extremely clearly written and easily implemented in any language
you like. I&amp;rsquo;m not going to explain any of the math here!&lt;/p>
&lt;p>The discussion on co-ordinate systems in Red Blob Games&amp;rsquo;s guide is
very important to read before going to far into the development.
I settled on the Axial coordinate system described in the guide.&lt;/p>
&lt;p>I didn&amp;rsquo;t consider the offset coordinate systems desscribed there for
long because the math is annoying for neighbours, directions, distances
etc. They were easiest to deal with by converting offset to cube or
axial coordinates and if that&amp;rsquo;s the case I might as well use cube or
axial natively.&lt;/p>
&lt;p>Comparing axial to cube, the big advantage of axial is that the
coordinates are always valid, as they are in offset systems. That is,
a random value for each coordinate dimension is always okay, but
with cube coordinates valid coordinates are only where they sum to zero.&lt;/p>
&lt;p>Since the vector math for axial is nothing unusual, we can use
Godot&amp;rsquo;s &lt;code>Vector2i&lt;/code> type for an axial coordinate. I&amp;rsquo;m using &lt;code>Vector3i&lt;/code>
for cube coordinates and there&amp;rsquo;s conversion functions between them
documented in the Red Blob Games guide.&lt;/p>
&lt;p>The conversion from axial to world (ie, where we place a hex on a flat
plane) is also in the guide and is easy to implement. That makes
positioning in the game&amp;rsquo;s 3D world coordinate space quick to do.&lt;/p>
&lt;h2 id="camera">Camera&lt;/h2>
&lt;p>Hexagon tile games are commonly seen with both perspective cameras and
orthographic cameras. The difference between the two is something you
are best just firing at a search engine, but the tldr is perspective
is what we see normally (far away objects are smaller), and ortographic
keeps everything the same size regardless of distance.&lt;/p>
&lt;p>The latter camera has the same look as games that use a 2D engine with
tiles that fake 3Dness, the classic &amp;ldquo;isometric&amp;rdquo; look. That particular
look is historically very common for an RPG or tile base game.&lt;/p>
&lt;p>Although it&amp;rsquo;s tempting to ram home the somewhat retro ideas in the
game by using an isometric (or approximately isometric) view, I&amp;rsquo;ve
ended up using a perspective camera as I have had endless
problems with Godot&amp;rsquo;s orthographic camera, ranging from clipping
models to annoying lighting behaviour.&lt;/p>
&lt;p>I know that there&amp;rsquo;s a big chunk of this which is just my understanding
of how to correctly configure and drive the camera, but perspective
&amp;ldquo;Just Works&amp;rdquo; and it&amp;rsquo;s perfectly valid for a tile RPG (or other hexagonal
grid games, like Civilization), so I&amp;rsquo;m taking the path of least resistance.&lt;/p>
&lt;h2 id="hexagon-storage">Hexagon storage&lt;/h2>
&lt;p>The Red Blob Games guide to Hexagon grids discusses some issues around
storage, but this is actually a pretty easy decision.&lt;/p>
&lt;p>Since Godot provides &lt;code>Dictionary&lt;/code> type, and we can use axial coordinates
(really &lt;code>Vector2i&lt;/code>) as keys, it is the fastest and easiest way to store the map data. It
will tolerate any shape and holes or partially generated state. It has
fast access since it uses a hash to return the content of a specific
key, it enforces unique keys, and walking the whole map is no harder
than any other storage approach. It stores about as efficiently as
is possible.&lt;/p>
&lt;p>As I&amp;rsquo;m using axial coordinates, there are helper functions to do
things like return the neighours of a coordinate, or the tile in a
specific direction and distance, and so forth. We don&amp;rsquo;t rely
on the data storage structure to provide those constructs, so it
doesn&amp;rsquo;t matter that the storage has no concept of these.&lt;/p>
&lt;p>However, there&amp;rsquo;s one issue with storage of a world..&lt;/p>
&lt;h2 id="infinite-vs-finite">Infinite vs Finite&lt;/h2>
&lt;p>I am a fan of infinite prodcedural worlds. But for this game, I
don&amp;rsquo;t think we need a world we move infinitely in any direction, as
we can provide new generated challenges within a finite world.&lt;/p>
&lt;p>Not allowing the world to be infinite has several benefits. For one, world
generation is simplier if the world is finite, as we can simply
iterate over the world multiple times to add features to it. With
infinite worlds, each area or chunk (generally) needs to be generated
independently and unexpectedly.&lt;/p>
&lt;p>The other comes with approaching difficulty for the player. Rather than
having the difficulty determined by some value proportionate to
experience or gear, I would like difficulty to be determined by the
location the player is at.&lt;/p>
&lt;p>That is, difficulty is a function of the distance from a &amp;ldquo;safe&amp;rdquo; point
to the edge of the world. For easy implementation, we&amp;rsquo;ll set the safe
point to the literal center of the world (&lt;code>Vector2i(0,0)&lt;/code>). This means
when the player travels far away from the center the challenges are
more difficult, but they can easily control what challenges they want
to manage just by moving around.&lt;/p>
&lt;p>With an infinite world, you can do this, but I feel like it takes
away from one of the values of an infinite world (that is, you can just &amp;ldquo;explore&amp;rdquo;
and you aren&amp;rsquo;t bound to the same place, but you can&amp;rsquo;t if the difficulty
gets worse the further you are out).&lt;/p>
&lt;p>At the same time, I can hand-wave away the storage of the world needing
chunks because we don&amp;rsquo;t need chunks straight away for a finite world.
Let&amp;rsquo;s just make the whole world sit in RAM. What could go wrong?&lt;/p>
&lt;h2 id="wraping-up">Wraping up&lt;/h2>
&lt;p>Thus, the game being written is:&lt;/p>
&lt;ul>
&lt;li>A finite world, so we can cut corners on world gen&lt;/li>
&lt;li>Difficulty scales by distance from the centre, in which case we
can just use a &amp;ldquo;circular&amp;rdquo; (actually big hexagon) shape for the world&lt;/li>
&lt;li>Perspective because Orthogonal camera disagrees with me&lt;/li>
&lt;li>Doesn&amp;rsquo;t yet try to do anything to load/save/cache chunks but just
has everything in memory at once&lt;/li>
&lt;/ul>
&lt;p>There&amp;rsquo;s other decisions yet to come, but this&amp;rsquo;ll do for now.&lt;/p></description></item><item><title>Hexagon Game: Update for 12 October 2022</title><link>https://dave2.github.io/post/hexagon-update-2022-10-12/</link><pubDate>Wed, 12 Oct 2022 11:47:55 +1300</pubDate><guid>https://dave2.github.io/post/hexagon-update-2022-10-12/</guid><description>&lt;p>Well there&amp;rsquo;s been a little bit more progress on world generation. I&amp;rsquo;ve
been avoiding working on roads (I have a theory) and rivers (lol no
ideas), and doing &amp;ldquo;city&amp;rdquo; generation.&lt;/p>
&lt;p>Placing the cities is easy enough. The world is divided into biomes,
and we assign one city to each biome, checking to make sure when
we place it there are no other cities too close. We also check against
a reserved starting area.&lt;/p>
&lt;p>The biggest problem is then names. These have to be sourced on demand
from .. something. The best way would be names which were generated
as needed, that were vaguely consistent with a language (ie, &amp;ldquo;hhhhhhhf&amp;rdquo;
is not a great city name) and which didn&amp;rsquo;t just come from a fixed list
(because I am not that creative).&lt;/p>
&lt;p>One way would be to just use any one of a number of online generators
to produce a &amp;ldquo;long enough&amp;rdquo; list for the game, and I did think about
doing this. It wouldn&amp;rsquo;t be as elegant as actual name generation on
the fly, but it&amp;rsquo;s simple to implement.&lt;/p>
&lt;p>Although &amp;ldquo;simple to implement&amp;rdquo; is often my approach&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>, there were
some open source name generators based on a very classical approach
called Markov Chains. These produce new &amp;ldquo;words&amp;rdquo; by statistical
analysis of some input word lists and then making new combinations
from the observed patterns in the lists plus some randomness.&lt;/p>
&lt;p>There wasn&amp;rsquo;t any good examples I liked in GDscript, so porting one
from another language was the next best thing. Despite how awful
I am usually at writing code, I read it fairly well and have read
enough in a variety of languages to be able to work out how to
translate it to another language.&lt;/p>
&lt;p>One of the biggest problems with doing that sort of porting is the
actual algorithm can be opaque enough that the translation is merely
shifting one language&amp;rsquo;s syntax to another syntax and a little bit of
massaging how it uses types and built-in functions.&lt;/p>
&lt;p>Usually these things don&amp;rsquo;t come with a nice set of tests to show
the outcome of any function works as expected. This means when it
doesn&amp;rsquo;t work, if you don&amp;rsquo;t know the algorithm it an be pretty hard
to see where it&amp;rsquo;s going wrong.&lt;/p>
&lt;p>After a few days of headscratching, I did finally find the cause of
the code not producing any useful words: substrings. In the original
langauge, there&amp;rsquo;s a function &lt;code>substring()&lt;/code> which obviously would
map to &lt;code>substr()&lt;/code> in GDscript: give me some part of the string.&lt;/p>
&lt;p>But it turned out these two functions had different meanings for
their inputs: In GDscript it&amp;rsquo;s &lt;code>substr(start,len)&lt;/code> while the original
langauge I was porting from used &lt;code>substring(start,end)&lt;/code>. It had
&lt;em>another&lt;/em> function, &lt;code>substr()&lt;/code> as well which implemented the same
handling as GDscript&amp;rsquo;s &lt;code>substr()&lt;/code>. But this wasn&amp;rsquo;t obvious when
I did my awful lazy conversion pass over the code.&lt;/p>
&lt;p>Never mind, now it works. We have cities with generated names and
a way to generate names for lots of other things.&lt;/p>
&lt;p>At some point I&amp;rsquo;ll publish the GDscript code under the same license
as the original if anyone wants it. I wouldn&amp;rsquo;t trust it though!&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Some readers will be aware that in the past my view of &amp;ldquo;simple&amp;rdquo;
has included just ignoring huge sections of RFCs because they are
not &amp;ldquo;really&amp;rdquo; needed. That&amp;rsquo;s how simple I sometimes reach.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Never Complete Games: Hexagon</title><link>https://dave2.github.io/post/never-complete-games-hexagon/</link><pubDate>Mon, 10 Oct 2022 13:17:56 +1300</pubDate><guid>https://dave2.github.io/post/never-complete-games-hexagon/</guid><description>&lt;h2 id="whats-all-this-then">What&amp;rsquo;s all this then?&lt;/h2>
&lt;p>From time to time I get this idea I can and should write video games.
Which usually doesn&amp;rsquo;t end well, but hey, it&amp;rsquo;s something which passes
the time.&lt;/p>
&lt;p>This round I&amp;rsquo;ve decided to go with a classic procedural RPG using
hexagon tiles and a top-down perspective camera. I tried using an
othrographic camera and yet again I ran into issues with how it was
culling shapes close and far from the camera.&lt;/p>
&lt;p>Perspective works just fine with a narrow field of view, and everything
is much easier to drive spatially with it. Orthographic camera just
always ended in tears failing to understand how to move it well and
keep stuff in view.&lt;/p>
&lt;p>Anyway, this one seems to be actually holding my attention, so at some
point I will release .. bwhahaha who am I kidding. This may never see
light of day, but we shall see.&lt;/p>
&lt;p>At the moment it&amp;rsquo;s only running on PC because Reasons. The main one is
that Godot 4.0 beta has broken Android support for certain GPUs in
Android phones. It tries to set up fancy Variable Rate Shading which
my potato of a phone does not like.&lt;/p>
&lt;p>I&amp;rsquo;ll post more screenshots when there&amp;rsquo;s more game to show!&lt;/p></description></item><item><title>Wat Another Blog Again</title><link>https://dave2.github.io/post/wat-another-blog-again/</link><pubDate>Mon, 10 Oct 2022 12:55:42 +1300</pubDate><guid>https://dave2.github.io/post/wat-another-blog-again/</guid><description>&lt;h2 id="what-happened-this-time">What happened this time?&lt;/h2>
&lt;p>Yep, I&amp;rsquo;ve gone and built yet another blog. This time I can&amp;rsquo;t be
bothered hosting it on my own magic domain so for now it&amp;rsquo;s just
in GitHub Pages.&lt;/p>
&lt;h2 id="its-still-hugo">It&amp;rsquo;s still Hugo?&lt;/h2>
&lt;p>Yes, still based on Hugo. I have a real love for static site
generation even if it&amp;rsquo;s sometimes a pain to work with. This time
I&amp;rsquo;ve used some guide on using GH Actions to make this work, so I
can just &lt;code>git push&lt;/code> and stuff happens.&lt;/p>
&lt;p>I mean, it doesn&amp;rsquo;t help the content quality but it sure is pretty.&lt;/p>
&lt;h2 id="content-theme">Content theme?&lt;/h2>
&lt;p>In the past I&amp;rsquo;ve tried to stick to a theme, like technology or
whatever. I don&amp;rsquo;t think I&amp;rsquo;ll do that this time. It&amp;rsquo;ll be whatever
I feel like rambling about with no good reason.&lt;/p>
&lt;h2 id="this-is-not-that">This is not that&lt;/h2>
&lt;p>I have to put this here. These are my own views and not those of
anyone else or any other organisation I may be associated with in
any capacity blah blah.&lt;/p>
&lt;p>It won&amp;rsquo;t stop someone having a go of course.&lt;/p></description></item></channel></rss>