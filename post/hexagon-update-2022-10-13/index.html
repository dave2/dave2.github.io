<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hexagon Game Update: The Past | Loosely Coherent Ramblings</title><meta name=keywords content><meta name=description content="I realised that since I started writing this silly wee game I actually haven&rsquo;t written down any of the initial thoughts about how this was goign to work, and since I&rsquo;ve only just resurrected writing a blog after I&rsquo;d already started writing the game there&rsquo;s no history here either.
Right, let&rsquo;s see about writing some of those thoughts down.
Hexagon tiles I&rsquo;m implementing a classical RPG and hexagon tiles are pretty common for maps in that context."><meta name=author content><link rel=canonical href=https://dave2.github.io/post/hexagon-update-2022-10-13/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://dave2.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dave2.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dave2.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://dave2.github.io/apple-touch-icon.png><link rel=mask-icon href=https://dave2.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Hexagon Game Update: The Past"><meta property="og:description" content="I realised that since I started writing this silly wee game I actually haven&rsquo;t written down any of the initial thoughts about how this was goign to work, and since I&rsquo;ve only just resurrected writing a blog after I&rsquo;d already started writing the game there&rsquo;s no history here either.
Right, let&rsquo;s see about writing some of those thoughts down.
Hexagon tiles I&rsquo;m implementing a classical RPG and hexagon tiles are pretty common for maps in that context."><meta property="og:type" content="article"><meta property="og:url" content="https://dave2.github.io/post/hexagon-update-2022-10-13/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-13T12:29:46+13:00"><meta property="article:modified_time" content="2022-10-13T12:29:46+13:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hexagon Game Update: The Past"><meta name=twitter:description content="I realised that since I started writing this silly wee game I actually haven&rsquo;t written down any of the initial thoughts about how this was goign to work, and since I&rsquo;ve only just resurrected writing a blog after I&rsquo;d already started writing the game there&rsquo;s no history here either.
Right, let&rsquo;s see about writing some of those thoughts down.
Hexagon tiles I&rsquo;m implementing a classical RPG and hexagon tiles are pretty common for maps in that context."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dave2.github.io/post/"},{"@type":"ListItem","position":2,"name":"Hexagon Game Update: The Past","item":"https://dave2.github.io/post/hexagon-update-2022-10-13/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hexagon Game Update: The Past","name":"Hexagon Game Update: The Past","description":"I realised that since I started writing this silly wee game I actually haven\u0026rsquo;t written down any of the initial thoughts about how this was goign to work, and since I\u0026rsquo;ve only just resurrected writing a blog after I\u0026rsquo;d already started writing the game there\u0026rsquo;s no history here either.\nRight, let\u0026rsquo;s see about writing some of those thoughts down.\nHexagon tiles I\u0026rsquo;m implementing a classical RPG and hexagon tiles are pretty common for maps in that context.","keywords":[],"articleBody":"I realised that since I started writing this silly wee game I actually haven’t written down any of the initial thoughts about how this was goign to work, and since I’ve only just resurrected writing a blog after I’d already started writing the game there’s no history here either.\nRight, let’s see about writing some of those thoughts down.\nHexagon tiles I’m implementing a classical RPG and hexagon tiles are pretty common for maps in that context. Square maps are also an option, but I feel like they lend themselves better to worlds where you and the party are in fine-definition worlds, where hexagons are better at coarse-definition worlds.\nSo for example, in a fine-definition world a city or a village is a large number of tiles, you have the city’s streets to actually navigate around etc. In a coarse-definition world the city is one tile, possibly with some visual sugar around that, but internal city views are a bit more menu-like and less navigated using tiles.\nThis does also make some types of generation of the world a bit easier, because we really only looking at high-level detail and that has a lot fewer elements to try to model. Cities are just a single world position and not a complex map of tiles within the world.\nThat said, there’s nothing stopping me from implementing a nested world approach - where entering a city essentially creates a new hexagon map at a finer level of detail - so we’re not really closing ourselves off on doing that level of detail. It would always be a scene switch to do it, however.\nSince I’m pretty rubbish at art, I’m leaning into Kenney’s Assets which include a Hexagon Tile Kit. So we have enough art to do world generation and some idea what the tile set should be able to do, if I can write the supporting code. If you have an interest in game dev but not much ability in art, then you really should look at Kenney’s work as it’s high quality and available under very generous license terms.\nThe tile set is flexible enough to be coarse or fine-definition, for the most part. There’s some gaps here and there but for this game in this state the gaps are just small workarounds.\nHexagon math Having a set of actual 3D tiles is all very well but you have to position them. The positioning is some very well documented math, the resource I used is Red Blob Games Hexagonal Grids which is extremely clearly written and easily implemented in any language you like. I’m not going to explain any of the math here!\nThe discussion on co-ordinate systems in Red Blob Games’s guide is very important to read before going to far into the development. I settled on the Axial coordinate system described in the guide.\nI didn’t consider the offset coordinate systems desscribed there for long because the math is annoying for neighbours, directions, distances etc. They were easiest to deal with by converting offset to cube or axial coordinates and if that’s the case I might as well use cube or axial natively.\nComparing axial to cube, the big advantage of axial is that the coordinates are always valid, as they are in offset systems. That is, a random value for each coordinate dimension is always okay, but with cube coordinates valid coordinates are only where they sum to zero.\nSince the vector math for axial is nothing unusual, we can use Godot’s Vector2i type for an axial coordinate. I’m using Vector3i for cube coordinates and there’s conversion functions between them documented in the Red Blob Games guide.\nThe conversion from axial to world (ie, where we place a hex on a flat plane) is also in the guide and is easy to implement. That makes positioning in the game’s 3D world coordinate space quick to do.\nCamera Hexagon tile games are commonly seen with both perspective cameras and orthographic cameras. The difference between the two is something you are best just firing at a search engine, but the tldr is perspective is what we see normally (far away objects are smaller), and ortographic keeps everything the same size regardless of distance.\nThe latter camera has the same look as games that use a 2D engine with tiles that fake 3Dness, the classic “isometric” look. That particular look is historically very common for an RPG or tile base game.\nAlthough it’s tempting to ram home the somewhat retro ideas in the game by using an isometric (or approximately isometric) view, I’ve ended up using a perspective camera as I have had endless problems with Godot’s orthographic camera, ranging from clipping models to annoying lighting behaviour.\nI know that there’s a big chunk of this which is just my understanding of how to correctly configure and drive the camera, but perspective “Just Works” and it’s perfectly valid for a tile RPG (or other hexagonal grid games, like Civilization), so I’m taking the path of least resistance.\nHexagon storage The Red Blob Games guide to Hexagon grids discusses some issues around storage, but this is actually a pretty easy decision.\nSince Godot provides Dictionary type, and we can use axial coordinates (really Vector2i) as keys, it is the fastest and easiest way to store the map data. It will tolerate any shape and holes or partially generated state. It has fast access since it uses a hash to return the content of a specific key, it enforces unique keys, and walking the whole map is no harder than any other storage approach. It stores about as efficiently as is possible.\nAs I’m using axial coordinates, there are helper functions to do things like return the neighours of a coordinate, or the tile in a specific direction and distance, and so forth. We don’t rely on the data storage structure to provide those constructs, so it doesn’t matter that the storage has no concept of these.\nHowever, there’s one issue with storage of a world..\nInfinite vs Finite I am a fan of infinite prodcedural worlds. But for this game, I don’t think we need a world we move infinitely in any direction, as we can provide new generated challenges within a finite world.\nNot allowing the world to be infinite has several benefits. For one, world generation is simplier if the world is finite, as we can simply iterate over the world multiple times to add features to it. With infinite worlds, each area or chunk (generally) needs to be generated independently and unexpectedly.\nThe other comes with approaching difficulty for the player. Rather than having the difficulty determined by some value proportionate to experience or gear, I would like difficulty to be determined by the location the player is at.\nThat is, difficulty is a function of the distance from a “safe” point to the edge of the world. For easy implementation, we’ll set the safe point to the literal center of the world (Vector2i(0,0)). This means when the player travels far away from the center the challenges are more difficult, but they can easily control what challenges they want to manage just by moving around.\nWith an infinite world, you can do this, but I feel like it takes away from one of the values of an infinite world (that is, you can just “explore” and you aren’t bound to the same place, but you can’t if the difficulty gets worse the further you are out).\nAt the same time, I can hand-wave away the storage of the world needing chunks because we don’t need chunks straight away for a finite world. Let’s just make the whole world sit in RAM. What could go wrong?\nWraping up Thus, the game being written is:\nA finite world, so we can cut corners on world gen Difficulty scales by distance from the centre, in which case we can just use a “circular” (actually big hexagon) shape for the world Perspective because Orthogonal camera disagrees with me Doesn’t yet try to do anything to load/save/cache chunks but just has everything in memory at once There’s other decisions yet to come, but this’ll do for now.\n","wordCount":"1364","inLanguage":"en","datePublished":"2022-10-13T12:29:46+13:00","dateModified":"2022-10-13T12:29:46+13:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://dave2.github.io/post/hexagon-update-2022-10-13/"},"publisher":{"@type":"Organization","name":"Loosely Coherent Ramblings","logo":{"@type":"ImageObject","url":"https://dave2.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dave2.github.io/ accesskey=h title="Loosely Coherent Ramblings (Alt + H)">Loosely Coherent Ramblings</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Hexagon Game Update: The Past</h1><div class=post-meta><span title='2022-10-13 12:29:46 +1300 +1300'>October 13, 2022</span></div></header><div class=post-content><p>I realised that since I started writing this silly wee game I actually
haven&rsquo;t written down any of the initial thoughts about how this was
goign to work, and since I&rsquo;ve only just resurrected writing a blog
after I&rsquo;d already started writing the game there&rsquo;s no history here
either.</p><p>Right, let&rsquo;s see about writing some of those thoughts down.</p><h2 id=hexagon-tiles>Hexagon tiles<a hidden class=anchor aria-hidden=true href=#hexagon-tiles>#</a></h2><p>I&rsquo;m implementing a classical RPG and hexagon tiles are pretty common
for maps in that context. Square maps are also an option, but I feel
like they lend themselves better to worlds where you and the party
are in fine-definition worlds, where hexagons are better at
coarse-definition worlds.</p><p>So for example, in a fine-definition world a city or a village
is a large number of tiles, you have the city&rsquo;s streets to actually
navigate around etc. In a coarse-definition world the city is one
tile, possibly with some visual sugar around that, but internal
city views are a bit more menu-like and less navigated using tiles.</p><p>This does also make some types of generation of the world a bit
easier, because we really only looking at high-level detail and
that has a lot fewer elements to try to model. Cities are just a
single world position and not a complex map of tiles within the world.</p><p>That said, there&rsquo;s nothing stopping me from implementing a nested
world approach - where entering a city essentially creates a new
hexagon map at a finer level of detail - so we&rsquo;re not really closing
ourselves off on doing that level of detail. It would always be a
scene switch to do it, however.</p><p>Since I&rsquo;m pretty rubbish at art, I&rsquo;m leaning into <a href=https://kenney.nl/assets/>Kenney&rsquo;s Assets</a>
which include a <a href=https://kenney.nl/assets/hexagon-kit>Hexagon Tile Kit</a>.
So we have enough art to do world generation and some idea what the
tile set <em>should</em> be able to do, if I can write the supporting code.
If you have an interest in game dev but not much ability in art, then
you really should look at Kenney&rsquo;s work as it&rsquo;s high quality and
available under very generous license terms.</p><p>The tile set is flexible enough to be coarse or fine-definition, for
the most part. There&rsquo;s some gaps here and there but for this game in
this state the gaps are just small workarounds.</p><h2 id=hexagon-math>Hexagon math<a hidden class=anchor aria-hidden=true href=#hexagon-math>#</a></h2><p>Having a set of actual 3D tiles is all very well but you have to
position them. The positioning is
some very well documented math, the resource I used is <a href=https://www.redblobgames.com/grids/hexagons/>Red Blob Games Hexagonal Grids</a>
which is extremely clearly written and easily implemented in any language
you like. I&rsquo;m not going to explain any of the math here!</p><p>The discussion on co-ordinate systems in Red Blob Games&rsquo;s guide is
very important to read before going to far into the development.
I settled on the Axial coordinate system described in the guide.</p><p>I didn&rsquo;t consider the offset coordinate systems desscribed there for
long because the math is annoying for neighbours, directions, distances
etc. They were easiest to deal with by converting offset to cube or
axial coordinates and if that&rsquo;s the case I might as well use cube or
axial natively.</p><p>Comparing axial to cube, the big advantage of axial is that the
coordinates are always valid, as they are in offset systems. That is,
a random value for each coordinate dimension is always okay, but
with cube coordinates valid coordinates are only where they sum to zero.</p><p>Since the vector math for axial is nothing unusual, we can use
Godot&rsquo;s <code>Vector2i</code> type for an axial coordinate. I&rsquo;m using <code>Vector3i</code>
for cube coordinates and there&rsquo;s conversion functions between them
documented in the Red Blob Games guide.</p><p>The conversion from axial to world (ie, where we place a hex on a flat
plane) is also in the guide and is easy to implement. That makes
positioning in the game&rsquo;s 3D world coordinate space quick to do.</p><h2 id=camera>Camera<a hidden class=anchor aria-hidden=true href=#camera>#</a></h2><p>Hexagon tile games are commonly seen with both perspective cameras and
orthographic cameras. The difference between the two is something you
are best just firing at a search engine, but the tldr is perspective
is what we see normally (far away objects are smaller), and ortographic
keeps everything the same size regardless of distance.</p><p>The latter camera has the same look as games that use a 2D engine with
tiles that fake 3Dness, the classic &ldquo;isometric&rdquo; look. That particular
look is historically very common for an RPG or tile base game.</p><p>Although it&rsquo;s tempting to ram home the somewhat retro ideas in the
game by using an isometric (or approximately isometric) view, I&rsquo;ve
ended up using a perspective camera as I have had endless
problems with Godot&rsquo;s orthographic camera, ranging from clipping
models to annoying lighting behaviour.</p><p>I know that there&rsquo;s a big chunk of this which is just my understanding
of how to correctly configure and drive the camera, but perspective
&ldquo;Just Works&rdquo; and it&rsquo;s perfectly valid for a tile RPG (or other hexagonal
grid games, like Civilization), so I&rsquo;m taking the path of least resistance.</p><h2 id=hexagon-storage>Hexagon storage<a hidden class=anchor aria-hidden=true href=#hexagon-storage>#</a></h2><p>The Red Blob Games guide to Hexagon grids discusses some issues around
storage, but this is actually a pretty easy decision.</p><p>Since Godot provides <code>Dictionary</code> type, and we can use axial coordinates
(really <code>Vector2i</code>) as keys, it is the fastest and easiest way to store the map data. It
will tolerate any shape and holes or partially generated state. It has
fast access since it uses a hash to return the content of a specific
key, it enforces unique keys, and walking the whole map is no harder
than any other storage approach. It stores about as efficiently as
is possible.</p><p>As I&rsquo;m using axial coordinates, there are helper functions to do
things like return the neighours of a coordinate, or the tile in a
specific direction and distance, and so forth. We don&rsquo;t rely
on the data storage structure to provide those constructs, so it
doesn&rsquo;t matter that the storage has no concept of these.</p><p>However, there&rsquo;s one issue with storage of a world..</p><h2 id=infinite-vs-finite>Infinite vs Finite<a hidden class=anchor aria-hidden=true href=#infinite-vs-finite>#</a></h2><p>I am a fan of infinite prodcedural worlds. But for this game, I
don&rsquo;t think we need a world we move infinitely in any direction, as
we can provide new generated challenges within a finite world.</p><p>Not allowing the world to be infinite has several benefits. For one, world
generation is simplier if the world is finite, as we can simply
iterate over the world multiple times to add features to it. With
infinite worlds, each area or chunk (generally) needs to be generated
independently and unexpectedly.</p><p>The other comes with approaching difficulty for the player. Rather than
having the difficulty determined by some value proportionate to
experience or gear, I would like difficulty to be determined by the
location the player is at.</p><p>That is, difficulty is a function of the distance from a &ldquo;safe&rdquo; point
to the edge of the world. For easy implementation, we&rsquo;ll set the safe
point to the literal center of the world (<code>Vector2i(0,0)</code>). This means
when the player travels far away from the center the challenges are
more difficult, but they can easily control what challenges they want
to manage just by moving around.</p><p>With an infinite world, you can do this, but I feel like it takes
away from one of the values of an infinite world (that is, you can just &ldquo;explore&rdquo;
and you aren&rsquo;t bound to the same place, but you can&rsquo;t if the difficulty
gets worse the further you are out).</p><p>At the same time, I can hand-wave away the storage of the world needing
chunks because we don&rsquo;t need chunks straight away for a finite world.
Let&rsquo;s just make the whole world sit in RAM. What could go wrong?</p><h2 id=wraping-up>Wraping up<a hidden class=anchor aria-hidden=true href=#wraping-up>#</a></h2><p>Thus, the game being written is:</p><ul><li>A finite world, so we can cut corners on world gen</li><li>Difficulty scales by distance from the centre, in which case we
can just use a &ldquo;circular&rdquo; (actually big hexagon) shape for the world</li><li>Perspective because Orthogonal camera disagrees with me</li><li>Doesn&rsquo;t yet try to do anything to load/save/cache chunks but just
has everything in memory at once</li></ul><p>There&rsquo;s other decisions yet to come, but this&rsquo;ll do for now.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://dave2.github.io/>Loosely Coherent Ramblings</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>