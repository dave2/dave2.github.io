<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hexagon Update: 25 Oct 2022 | Loosely Coherent Ramblings</title><meta name=keywords content><meta name=description content="Lots since the last update, lets dive into it.
Refactoring Outcome Refactoring all the road generation to use tile variants instead of laying a separate prefab on top was a Huge Success and was definitely the right approach.
Baking the roads into the tile set took a while but it resulted in a much nicer implementation internally, as I took the chance to also drop object pooling.
An optimization I had done very early on was to push 3D tiles into a pool of pre-instantiated objects and pull them into the world as needed."><meta name=author content><link rel=canonical href=https://dave2.github.io/post/hexagon-update-2022-10-25/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://dave2.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dave2.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dave2.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://dave2.github.io/apple-touch-icon.png><link rel=mask-icon href=https://dave2.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Hexagon Update: 25 Oct 2022"><meta property="og:description" content="Lots since the last update, lets dive into it.
Refactoring Outcome Refactoring all the road generation to use tile variants instead of laying a separate prefab on top was a Huge Success and was definitely the right approach.
Baking the roads into the tile set took a while but it resulted in a much nicer implementation internally, as I took the chance to also drop object pooling.
An optimization I had done very early on was to push 3D tiles into a pool of pre-instantiated objects and pull them into the world as needed."><meta property="og:type" content="article"><meta property="og:url" content="https://dave2.github.io/post/hexagon-update-2022-10-25/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-25T09:25:22+13:00"><meta property="article:modified_time" content="2022-10-25T09:25:22+13:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hexagon Update: 25 Oct 2022"><meta name=twitter:description content="Lots since the last update, lets dive into it.
Refactoring Outcome Refactoring all the road generation to use tile variants instead of laying a separate prefab on top was a Huge Success and was definitely the right approach.
Baking the roads into the tile set took a while but it resulted in a much nicer implementation internally, as I took the chance to also drop object pooling.
An optimization I had done very early on was to push 3D tiles into a pool of pre-instantiated objects and pull them into the world as needed."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dave2.github.io/post/"},{"@type":"ListItem","position":2,"name":"Hexagon Update: 25 Oct 2022","item":"https://dave2.github.io/post/hexagon-update-2022-10-25/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hexagon Update: 25 Oct 2022","name":"Hexagon Update: 25 Oct 2022","description":"Lots since the last update, lets dive into it.\nRefactoring Outcome Refactoring all the road generation to use tile variants instead of laying a separate prefab on top was a Huge Success and was definitely the right approach.\nBaking the roads into the tile set took a while but it resulted in a much nicer implementation internally, as I took the chance to also drop object pooling.\nAn optimization I had done very early on was to push 3D tiles into a pool of pre-instantiated objects and pull them into the world as needed.","keywords":[],"articleBody":"Lots since the last update, lets dive into it.\nRefactoring Outcome Refactoring all the road generation to use tile variants instead of laying a separate prefab on top was a Huge Success and was definitely the right approach.\nBaking the roads into the tile set took a while but it resulted in a much nicer implementation internally, as I took the chance to also drop object pooling.\nAn optimization I had done very early on was to push 3D tiles into a pool of pre-instantiated objects and pull them into the world as needed. This is fairly useful in most game engines, but actually in Godot it turns out it has no useful performance gain at all.\nIn Godot, the cost of .instantiate() is basically nothing and you get a much cleaner code path without involving your own object pool. You can just create objects and then .queue_free() them when done. The name of that function hints at what is going on under the hood, and something I hadn’t really noticed until I did the refactor.\nSo long as you’ve already loaded the resource, the cost of spawning many new ones at once is as low as all the work needed to maintain the object pool. Having an object pool adds huge complexity (mostly on the freeing side, you can’t just free the object, you need to “hand back” the object to the pool). Given all the extra complexity with no performance gain, it was a good thing to remove it entirely and write more simple code.\nStalling Having refactored all code around the map view and in turn the way we load tile type information, it was time to revisit world generation, but specifically about both how slow it ran and the lack of feedback.\nProviding feedback to the user is really important. If you’re given a blank screen with no visible activity, the instinct is the game has crashed or is otherwise misbehaving, and to kill it. It’s important while doing heavy work to show work being done, and ideally some indication about the progress of that work.\nOkay, no worries, Godot has progress bars and text I can display for such things. But despite sending updates to the progress bars and text, nothing rendered until it was all done.\nThe immediate approach I took was to slice off the world generation into a thread and then just wait around for that to complete. This sort of worked and then I changed things and it didn’t, and because I’m not the smartest person I couldn’t remember what was actually changed which made any difference.\nGodot supports threads, and all the supporting elements needed to make threads word (like mutexes and semaphores). Alas, adding all these in various places didn’t make the code behave any better. In one part of the code, we’d test if the thread was running and it would always return false, while the output showed the thread clearly still running and spamming the log with messages.\nIt also didn’t help that it started to look like sometimes if you called functions they actually somehow caused all the visual rendering to stall even if that function should have been in a thread.. right?\nTwo days later, I now have a better understanding of both Godot’s main loop and most of the downsides of threads. Not a fun two days.\nOne thing I had forgotten is by and large games are single-threaded. They might offload certain low level functions to a thread, like audio playing or physics, but many games (and game engines) are single threaded because there are less complications about data access and synchronization than a multi-threaded game or engine.\nIn Godot’s case, rendering and _ready() in a script share a thread, so if you block in _ready() then rendering ain’t going to work. But, I had “solved” this with making sure world gen was on a thread.\nWell, sort of. Yes, some of it was on a thread, but not all of it, and it was hard to identify what was actually executing where. A lot of print-as-debug was added with every line including the output of OS.get_thread_caller_id to show where this was really taking place.\nWhat I found was it looks like singletons in Godot always execute on the main thread, and the way to avoid this is ensure any functions you call are on separate objects in your thread. Okay, refactor around that a bit (the calls into the world map singleton are fast, so we’ll ignore they run in the main thread, but it meant world gen had to be separated from the singleton).\nStill, we had problems, threads were being reported to the main code as finished when the logs were full of signs they were running. Getting to the bottom of this I think came down to pure luck and writing a separate set of tests in a different Godot project.\nThe test case I wrote looked something like the following. Note in this example we have a script on a node called SimpleProgressBar which updates different elements, like upper and lower text messages as well as the bar itself.\nvar progress_bar : Node var m : Mutex func _ready(): # we'll use a progress bar for visuals progress_bar = get_node(\"SimpleProgressBar\") # we'll use this to protect our access m = Mutex.new() # start the long work thread var t = Thread.new() t.start(Callable(self,\"_long_work_thread\")) for i in range(0,100): # update the progress bar too! m.lock() progress_bar.set_progress(i) m.unlock() await get_tree().create_timer(1).timeout # wait for the thread to exist while t.is_alive(): await get_tree().create_timer(1).timeout # clean up thread (normally blocks unless thread is dead) t.wait_until_finished() func _long_work_thread(): for i in range(0,100): # update the progress bar, ensuring no-one else is m.lock() progress_bar.set_lower_text(\"Long process step %d\" % i) m.unlock() # simulate a long process OS.delay_msec(5000) Okay, so the test case worked, even though I was sure I was doing the same thing in my game code. The long work thread continues to update the progress bar and this visually updates, and the code in _ready() waits for the long work thread to complete. It turns out, I wasn’t, and the detail is interesting.\nThe use of await in _ready() is because we don’t want to block, we know that we can’t call OS.delay_msec() because it would block and then rendering would stop. In the thread, we can just block (after all, that’s the point of the thread), so we call OS.delay_msec().\nGoing back over my game code, surely it doesn’t matter in a thread if we block or not, the thread is separate and we can do what we like. Oh, no, we definitely can’t.\nLet’s use a non-blocking delay instead in the long work thread, change OS.delay_msec(5000) to await get_tree().create_timer(5).timeout which is the same 5 second delay. Suddenly now the main code in _ready doesn’t wait for the thread to finish, it just plows through having been told from the result of t.is_alive() that the thread is dead.\nIt appears that you cannot call await in a thread other than the main thread. For whatever reason, the thread is lost and forgotten and you can’t get back to it. It is not the case that creating a thread gives you the same properties as the main thread at all.\nThe reason this tripped me up is that I was also doing some fancy fades using tweens to the progress bar. The common way to write this (and comes up in all the searches BTW) is:\nvar tween = create_tween() tween.tween_property(progress_bar, \"modulate:a\", 1.0, 1.0) await t.finished So naturally, in my thread for doing long work, it started with that exact fragment. And then the thread blew up.\nIn fact, in the main loop we can do that, but we must block if we want to do that in a thread, and it becomes:\nvar tween = create_tween() tween.tween_property(progress_bar, \"modulate:a\", 1.0, 1.0) while tween.is_running(): OS.delay_msec(100) Annoyingly, this also still causes rendering issues, but mostly it seems to be because OS.delay_msec() might just busy-loop and so it starves something else of cycles, so you get stuttering and uneven tweens.\nThe alternative to a thread for long work is our friend await and littering your long work with lots of calls to await get_tree().process_frame which will gracefully leave to allow rendering to continue for a whole frame, and then come back. This is pretty much how a single-threaded game should be doing things, but it certainly feels rough to write.\nAnyway, that’s two days I won’t get back.\nI’m unsure if I’ll revert out of threads for things like world gen, or leave it there. Now it has no problems with unexplained “death” it works so I’m tempted not to touch that whole space for a while.\nPerformance was also problematic for generating the world (even in a nice thread). There were quite a few cases where I was using a Dictionary for performance and then throwing that all away by forcing GDscript to iterate over an Array, which is a lot slower.\nFor example, here’s a few of ways of testing if we have something:\nvar big_thing : Dictionary() # ... if big_thing.has(\"key\"): # ... if \"key\" in big_thing: # ... if \"key\" in big_thing.keys() # ... The first is obviously using the dictionary correctly. The second and third I thought were the same, because of the in operator. This is not the case: using in with a Dictionary is functionally the same as calling .has() on it, while using in with the result of .keys() of the Dictionary produces an Array and then uses the in operator on it which is really really slow.\nI’ve been mixing all three types without much care, and it actually matters a lot. I still randomly pick between x.has(key) and key in x which isn’t so good, but for now at least they both don’t suck.\nThis alone was responsible for a large amount of lost time in world generation.\nSaving and Loading After the fun with threads, I got on with actually useful progress (ha ha) and implemented saving and loading the game state. This is mostly easy, and apart from not clearing out some state when loading, it just works.\nSave games are packed binary files, because serialization to say JSON is kind of annoying. Lots of types you have to munge and can’t just call JSON.stringify() on a wodge of data. Instead you have to pick out and transform some things to strings before trying to throw them into JSON.\nIt’s not that stringify() can’t convert some types to strings, it does that just fine. It’s that the inverse function, parse() doesn’t understand how to reverse stringify() for all cases.\nTake a Vector2, the string version is something like \"(1.0, 2.0)\", which is just fine, it’s what JSON.stringify() produces, it’s valid JSON so all good. However, parse() just sees that as a string and gives you back .. a string. Fair enough, it is a string, but it’s a string you – Mr JSON class – put there. You want to give me back what I put into you? “Hell no” says Mr JSON class.\nThankfully, compared to the threading stuff, that’s easy to deal with. Don’t use JSON for save games.\nNext up Because I can’t leave well enough alone, I’m exploring a different tile set to the one currently being used. It has some nice features, like hexagons are more obviously visible, and a lot of interesting decorations for tiles.\nWhile playing around with a different tile set, it’s also become clear I am not handling materials on tiles in a way that makes it a bit easier for me to tweak the tile colouring and surface. So we’ll also be fixing that for the tile sets as well.\n","wordCount":"1964","inLanguage":"en","datePublished":"2022-10-25T09:25:22+13:00","dateModified":"2022-10-25T09:25:22+13:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://dave2.github.io/post/hexagon-update-2022-10-25/"},"publisher":{"@type":"Organization","name":"Loosely Coherent Ramblings","logo":{"@type":"ImageObject","url":"https://dave2.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dave2.github.io/ accesskey=h title="Loosely Coherent Ramblings (Alt + H)">Loosely Coherent Ramblings</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dave2.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dave2.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://dave2.github.io/post/>Posts</a></div><h1 class=post-title>Hexagon Update: 25 Oct 2022</h1><div class=post-meta><span title='2022-10-25 09:25:22 +1300 +1300'>October 25, 2022</span></div></header><div class=post-content><p>Lots since the last update, lets dive into it.</p><h2 id=refactoring-outcome>Refactoring Outcome<a hidden class=anchor aria-hidden=true href=#refactoring-outcome>#</a></h2><p>Refactoring all the road generation to use tile variants instead of
laying a separate prefab on top was a Huge Success and was definitely
the right approach.</p><p>Baking the roads into the tile set took a while but it resulted in
a much nicer implementation internally, as I took the chance to also
drop object pooling.</p><p>An optimization I had done very early on was to push 3D tiles into a
pool of pre-instantiated objects and pull them into the world as
needed. This is fairly useful in most game engines, but actually in
Godot it turns out it has no useful performance gain at all.</p><p>In Godot, the cost of <code>.instantiate()</code> is basically nothing and you
get a much cleaner code path without involving your own object pool.
You can just create objects and then <code>.queue_free()</code> them when done.
The name of that function hints at what is going on under the hood,
and something I hadn&rsquo;t really noticed until I did the refactor.</p><p>So long as you&rsquo;ve already loaded the resource, the cost of spawning
many new ones at once is as low as all the work needed to maintain
the object pool. Having an object pool adds huge complexity (mostly
on the freeing side, you can&rsquo;t just free the object, you need to
&ldquo;hand back&rdquo; the object to the pool). Given all the extra complexity
with no performance gain, it was a good thing to remove it entirely
and write more simple code.</p><h2 id=stalling>Stalling<a hidden class=anchor aria-hidden=true href=#stalling>#</a></h2><p>Having refactored all code around the map view and in turn the way
we load tile type information, it was time to revisit world generation,
but specifically about both how slow it ran and the lack of feedback.</p><p>Providing feedback to the user is really important. If you&rsquo;re given
a blank screen with no visible activity, the instinct is the game
has crashed or is otherwise misbehaving, and to kill it. It&rsquo;s
important while doing heavy work to show work being done, and ideally
some indication about the progress of that work.</p><p>Okay, no worries, Godot has progress bars and text I can display for
such things. But despite sending updates to the progress bars and
text, nothing rendered until it was all done.</p><p>The immediate approach I took was to slice off the world generation
into a thread and then just wait around for that to complete. This
sort of worked and then I changed things and it didn&rsquo;t, and because
I&rsquo;m not the smartest person I couldn&rsquo;t remember what was actually
changed which made any difference.</p><p>Godot supports threads, and all the supporting elements needed to make
threads word (like mutexes and semaphores). Alas, adding all these
in various places didn&rsquo;t make the code behave any better. In one
part of the code, we&rsquo;d test if the thread was running and it would
always return false, while the output showed the thread <em>clearly</em>
still running and spamming the log with messages.</p><p>It also didn&rsquo;t help that it started to look like sometimes if you
called functions they actually somehow caused all the visual rendering
to stall even if that function should have been in a thread.. right?</p><p>Two days later, I now have a better understanding of both Godot&rsquo;s
main loop and most of the downsides of threads. Not a fun two days.</p><p>One thing I had forgotten is by and large games are single-threaded.
They might offload certain low level functions to a thread, like
audio playing or physics, but many games (and game engines) are
single threaded because there are less complications about data
access and synchronization than a multi-threaded game or engine.</p><p>In Godot&rsquo;s case, rendering and <code>_ready()</code> in a script share a thread,
so if you block in <code>_ready()</code> then rendering ain&rsquo;t going to work.
But, I had &ldquo;solved&rdquo; this with making sure world gen was on a thread.</p><p>Well, sort of. Yes, some of it was on a thread, but not all of it,
and it was hard to identify what was actually executing where. A lot
of print-as-debug was added with every line including the output of
<code>OS.get_thread_caller_id</code> to show where this was really taking place.</p><p>What I found was it looks like singletons in Godot always execute on
the main thread, and the way to avoid this is ensure any functions
you call are on separate objects in your thread. Okay, refactor
around that a bit (the calls into the world map singleton are fast,
so we&rsquo;ll ignore they run in the main thread, but it meant world gen
had to be separated from the singleton).</p><p>Still, we had problems, threads were being reported to the main
code as finished when the logs were full of signs they were running.
Getting to the bottom of this I think came down to pure luck and
writing a separate set of tests in a different Godot project.</p><p>The test case I wrote looked something like the following. Note in
this example we have a script on a node called <code>SimpleProgressBar</code>
which updates different elements, like upper and lower text messages
as well as the bar itself.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>var progress_bar : Node
</span></span><span style=display:flex><span>var m : Mutex
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func _ready():
</span></span><span style=display:flex><span>    <span style=color:#75715e># we&#39;ll use a progress bar for visuals</span>
</span></span><span style=display:flex><span>    progress_bar <span style=color:#f92672>=</span> get_node(<span style=color:#e6db74>&#34;SimpleProgressBar&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># we&#39;ll use this to protect our access</span>
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> Mutex<span style=color:#f92672>.</span>new()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># start the long work thread</span>
</span></span><span style=display:flex><span>    var t <span style=color:#f92672>=</span> Thread<span style=color:#f92672>.</span>new()
</span></span><span style=display:flex><span>    t<span style=color:#f92672>.</span>start(Callable(self,<span style=color:#e6db74>&#34;_long_work_thread&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>100</span>):
</span></span><span style=display:flex><span>        <span style=color:#75715e># update the progress bar too!</span>
</span></span><span style=display:flex><span>        m<span style=color:#f92672>.</span>lock()
</span></span><span style=display:flex><span>        progress_bar<span style=color:#f92672>.</span>set_progress(i)
</span></span><span style=display:flex><span>        m<span style=color:#f92672>.</span>unlock()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> get_tree()<span style=color:#f92672>.</span>create_timer(<span style=color:#ae81ff>1</span>)<span style=color:#f92672>.</span>timeout
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># wait for the thread to exist</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> t<span style=color:#f92672>.</span>is_alive():
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> get_tree()<span style=color:#f92672>.</span>create_timer(<span style=color:#ae81ff>1</span>)<span style=color:#f92672>.</span>timeout
</span></span><span style=display:flex><span>    <span style=color:#75715e># clean up thread (normally blocks unless thread is dead)</span>
</span></span><span style=display:flex><span>    t<span style=color:#f92672>.</span>wait_until_finished()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func _long_work_thread():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>100</span>):
</span></span><span style=display:flex><span>        <span style=color:#75715e># update the progress bar, ensuring no-one else is</span>
</span></span><span style=display:flex><span>        m<span style=color:#f92672>.</span>lock()
</span></span><span style=display:flex><span>        progress_bar<span style=color:#f92672>.</span>set_lower_text(<span style=color:#e6db74>&#34;Long process step </span><span style=color:#e6db74>%d</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> i)
</span></span><span style=display:flex><span>        m<span style=color:#f92672>.</span>unlock()
</span></span><span style=display:flex><span>        <span style=color:#75715e># simulate a long process</span>
</span></span><span style=display:flex><span>        OS<span style=color:#f92672>.</span>delay_msec(<span style=color:#ae81ff>5000</span>)
</span></span></code></pre></div><p>Okay, so the test case worked, even though I was sure I was doing
the same thing in my game code. The long work thread continues to
update the progress bar and this visually updates, and the code
in <code>_ready()</code> waits for the long work thread to complete.
It turns out, I wasn&rsquo;t, and the detail is interesting.</p><p>The use of <code>await</code> in <code>_ready()</code> is because we don&rsquo;t want to block,
we know that we can&rsquo;t call <code>OS.delay_msec()</code> because it would block
and then rendering would stop. In the thread, we <em>can</em> just block
(after all, that&rsquo;s the point of the thread), so we call <code>OS.delay_msec()</code>.</p><p>Going back over my game code, surely it doesn&rsquo;t matter in a thread
if we block or not, the thread is separate and we can do what we
like. Oh, no, we definitely can&rsquo;t.</p><p>Let&rsquo;s use a non-blocking delay instead in the long work thread, change
<code>OS.delay_msec(5000)</code> to <code>await get_tree().create_timer(5).timeout</code>
which is the same 5 second delay. Suddenly now the main code in
<code>_ready</code> doesn&rsquo;t wait for the thread to finish, it just plows through
having been told from the result of <code>t.is_alive()</code> that the thread
is dead.</p><p>It appears that you <em>cannot</em> call <code>await</code> in a thread other than the
main thread. For whatever reason, the thread is lost and forgotten
and you can&rsquo;t get back to it. It is not the case that creating a
thread gives you the same properties as the main thread <em>at all</em>.</p><p>The reason this tripped me up is that I was also doing some fancy
fades using tweens to the progress bar. The common way to write
this (and comes up in all the searches BTW) is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>var tween <span style=color:#f92672>=</span> create_tween()
</span></span><span style=display:flex><span>tween<span style=color:#f92672>.</span>tween_property(progress_bar, <span style=color:#e6db74>&#34;modulate:a&#34;</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>await</span> t<span style=color:#f92672>.</span>finished
</span></span></code></pre></div><p>So naturally, in my thread for doing long work, it started with
that exact fragment. And then the thread blew up.</p><p>In fact, in the main loop we can do that, but we <em>must</em> block if
we want to do that in a thread, and it becomes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>var tween <span style=color:#f92672>=</span> create_tween()
</span></span><span style=display:flex><span>tween<span style=color:#f92672>.</span>tween_property(progress_bar, <span style=color:#e6db74>&#34;modulate:a&#34;</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> tween<span style=color:#f92672>.</span>is_running():
</span></span><span style=display:flex><span>    OS<span style=color:#f92672>.</span>delay_msec(<span style=color:#ae81ff>100</span>)
</span></span></code></pre></div><p>Annoyingly, this also still causes rendering issues, but mostly
it seems to be because <code>OS.delay_msec()</code> might just busy-loop and
so it starves something else of cycles, so you get stuttering and
uneven tweens.</p><p>The alternative to a thread for long work is our friend <code>await</code> and
littering your long work with lots of calls to <code>await get_tree().process_frame</code>
which will gracefully leave to allow rendering to continue for a whole
frame, and then come back. This is pretty much how a single-threaded
game should be doing things, but it certainly feels rough to write.</p><p>Anyway, that&rsquo;s two days I won&rsquo;t get back.</p><p>I&rsquo;m unsure if I&rsquo;ll revert out of threads for things like world gen,
or leave it there. Now it has no problems with unexplained &ldquo;death&rdquo;
it works so I&rsquo;m tempted not to touch that whole space for a while.</p><p>Performance was also problematic for generating the world (even in
a nice thread). There were quite a few cases where I was using
a <code>Dictionary</code> for performance and then throwing that all away by
forcing GDscript to iterate over an <code>Array</code>, which is a lot slower.</p><p>For example, here&rsquo;s a few of ways of testing if we have something:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>var big_thing : Dictionary()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> big_thing<span style=color:#f92672>.</span>has(<span style=color:#e6db74>&#34;key&#34;</span>):
</span></span><span style=display:flex><span>    <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;key&#34;</span> <span style=color:#f92672>in</span> big_thing:
</span></span><span style=display:flex><span>    <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;key&#34;</span> <span style=color:#f92672>in</span> big_thing<span style=color:#f92672>.</span>keys()
</span></span><span style=display:flex><span>    <span style=color:#75715e># ...</span>
</span></span></code></pre></div><p>The first is obviously using the dictionary correctly. The second and
third I thought were the same, because of the <code>in</code> operator. This is
not the case: using <code>in</code> with a <code>Dictionary</code> is functionally the same
as calling <code>.has()</code> on it, while using <code>in</code> with the result of <code>.keys()</code>
of the <code>Dictionary</code> produces an <code>Array</code> and then uses the <code>in</code> operator
on it which is really really slow.</p><p>I&rsquo;ve been mixing all three types without much care, and it actually
matters a lot. I still randomly pick between <code>x.has(key)</code> and <code>key in x</code>
which isn&rsquo;t so good, but for now at least they both don&rsquo;t suck.</p><p>This alone was responsible for a large amount of lost time in world
generation.</p><h2 id=saving-and-loading>Saving and Loading<a hidden class=anchor aria-hidden=true href=#saving-and-loading>#</a></h2><p>After the fun with threads, I got on with actually useful progress
(ha ha) and implemented saving and loading the game state. This
is mostly easy, and apart from not clearing out some state when
loading, it just works.</p><p>Save games are packed binary files, because serialization to say
JSON is kind of annoying. Lots of types you <em>have</em> to munge and
can&rsquo;t just call <code>JSON.stringify()</code> on a wodge of data. Instead
you have to pick out and transform some things to strings before
trying to throw them into JSON.</p><p>It&rsquo;s not that <code>stringify()</code> can&rsquo;t convert some types to strings,
it does that just fine. It&rsquo;s that the inverse function, <code>parse()</code>
doesn&rsquo;t understand how to reverse <code>stringify()</code> for all cases.</p><p>Take a <code>Vector2</code>, the string version is something like <code>"(1.0, 2.0)"</code>,
which is just fine, it&rsquo;s what <code>JSON.stringify()</code> produces, it&rsquo;s valid
JSON so all good. However, <code>parse()</code> just sees that as a string and
gives you back .. a string. Fair enough, it <strong>is</strong> a string, but it&rsquo;s a
string you &ndash; Mr JSON class &ndash; put there. You want to give me back
what I put into you? &ldquo;Hell no&rdquo; says Mr JSON class.</p><p>Thankfully, compared to the threading stuff, that&rsquo;s easy to deal with.
Don&rsquo;t use JSON for save games.</p><h2 id=next-up>Next up<a hidden class=anchor aria-hidden=true href=#next-up>#</a></h2><p>Because I can&rsquo;t leave well enough alone, I&rsquo;m exploring a different
tile set to the one currently being used. It has some nice features,
like hexagons are more obviously visible, and a lot of interesting
decorations for tiles.</p><p>While playing around with a different tile set, it&rsquo;s also become
clear I am not handling materials on tiles in a way that makes it
a bit easier for me to tweak the tile colouring and surface. So
we&rsquo;ll also be fixing that for the tile sets as well.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://dave2.github.io/post/hexagon-update-2022-10-21/><span class=title>Next »</span><br><span>Hexagon Update: Oh no</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Hexagon Update: 25 Oct 2022 on twitter" href="https://twitter.com/intent/tweet/?text=Hexagon%20Update%3a%2025%20Oct%202022&url=https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-25%2f&hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hexagon Update: 25 Oct 2022 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-25%2f&title=Hexagon%20Update%3a%2025%20Oct%202022&summary=Hexagon%20Update%3a%2025%20Oct%202022&source=https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-25%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hexagon Update: 25 Oct 2022 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-25%2f&title=Hexagon%20Update%3a%2025%20Oct%202022"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hexagon Update: 25 Oct 2022 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-25%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hexagon Update: 25 Oct 2022 on whatsapp" href="https://api.whatsapp.com/send?text=Hexagon%20Update%3a%2025%20Oct%202022%20-%20https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-25%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hexagon Update: 25 Oct 2022 on telegram" href="https://telegram.me/share/url?text=Hexagon%20Update%3a%2025%20Oct%202022&url=https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-25%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://dave2.github.io/>Loosely Coherent Ramblings</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>