<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hexagon Update: Roads | Loosely Coherent Ramblings</title><meta name=keywords content="hexagon_game"><meta name=description content="As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.
The first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can&rsquo;t see them. Also, I expect I&rsquo;ll need to do extensive debugging on road generation and so I&rsquo;ll also need to see them."><meta name=author content><link rel=canonical href=https://dave2.github.io/post/hexagon-update-2022-10-17/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://dave2.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dave2.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dave2.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://dave2.github.io/apple-touch-icon.png><link rel=mask-icon href=https://dave2.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="Hexagon Update: Roads"><meta property="og:description" content="As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.
The first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can&rsquo;t see them. Also, I expect I&rsquo;ll need to do extensive debugging on road generation and so I&rsquo;ll also need to see them."><meta property="og:type" content="article"><meta property="og:url" content="https://dave2.github.io/post/hexagon-update-2022-10-17/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-17T11:38:22+13:00"><meta property="article:modified_time" content="2022-10-17T11:38:22+13:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hexagon Update: Roads"><meta name=twitter:description content="As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.
The first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can&rsquo;t see them. Also, I expect I&rsquo;ll need to do extensive debugging on road generation and so I&rsquo;ll also need to see them."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dave2.github.io/post/"},{"@type":"ListItem","position":2,"name":"Hexagon Update: Roads","item":"https://dave2.github.io/post/hexagon-update-2022-10-17/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hexagon Update: Roads","name":"Hexagon Update: Roads","description":"As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.\nThe first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can\u0026rsquo;t see them. Also, I expect I\u0026rsquo;ll need to do extensive debugging on road generation and so I\u0026rsquo;ll also need to see them.","keywords":["hexagon_game"],"articleBody":"As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.\nThe first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can’t see them. Also, I expect I’ll need to do extensive debugging on road generation and so I’ll also need to see them.\nThe tileset I’m using1 has roads as separate models to be added to the base tiles. The models cover all possible exit positions and combinations, although they have been normalised so some combinations and positions require rotating the model.\nYou can see the road tiles towards the bottom left corner of the image above (taken from Kenney.nl’s website).\nFor all of the tiles I’m using, I load these into the game based on some metadata about the tile, using a simple JSON file containing a list of the tiles and their metadata. For example, on the main tile set I have a metadata index containing:\n{ \"water\": { \"prefab_file\": \"Tiles/water.glb\", \"tags\": [ \"water\" ] }, \"grass\": { \"prefab_file\": \"Tiles/grass.glb\", \"tags\": [ \"grass\" ] } } (Aside: we actually read the metadata first and call load() on the prefab_file specified here, which gives us scenes to instance into the world. Everything is loaded into a Dictionary for easy access.)\nThe same approach is taken with road tiles, where we annotate what exits a given road piece has:\n[ { \"exits\": [ \"right\", \"left\" ], \"prefab_file\": \"Roads/path_straight.glb\" }, { \"exits\": [ \"right\" ], \"prefab_file\": \"Roads/path_start.glb\" } ] As mentioned above, each road piece needs to be rotated to produce all of the possible combinations. The path_straight.glb piece has two other rotations available, 60 degrees should give us exits of [ \"up_right\", \"down_left\" ], and 120 should give us [ \"down_right\", \"up_left\" ]. (Probably, I haven’t checked this is correct!)\nIn the first pass of this code, I just wrote out the combinations by hand, adding a \"rotation\" field to the metadata. But I quickly found this was cumbersome, more so when I got the exits for a given rotation wrong (usually 0 degrees, so everything from there was wrong!). Instead, we produce all of the other possible exit positions for a road piece by iterating over the six different possible rotations and rotating the exits at the same time.\nAt this point, it’s useful to talk about how I resolve a tile having a specific list of exits to a road piece. We need to ignore the order the exits were provided in, and we need a fast way to look it up.\nThe naive implementation would be to stick all the exit combinations into an array that points to the tile/rotation needed. Then we walk over every element in the array of combinations, and then on each combination (itself an array) we compare it to the array of exits we have.\nThis is slow, we’re walking all possible combinations, and then also doing a bunch of array walks and then string compares to compare the exit arrays. Now, maybe this is premature, but there are faster ways to do this.\nInstead of storing the possible exits as an array of strings, we convert them to a bitfield. This has a few advantages:\nIt reduces the exits to a fixed order, regardless of how they appear in the metadata Bitfields are trivial to compare, they end up just as an int Using an int as a Dictionary key is fast and reliable Rotating the exits is very easy in a bitfield Now some of my younger readers will be wondering why on earth I would go deep into integer math to do this. Well, my programming roots include a great deal of C (that’s C, not C++, not C#) on microcontrollers, and that space is all about bitfields. And one thing you learn quickly in that space is when you have very few cycles, bitfields are very efficient at solving a bunch of problems.\nDuring import of the road pieces, we convert the exits array for a piece into a bitfield. We do this by assigning a bit to each exit, and the order of the bits corospond to going around the possible rotations. In sort of psuedocode, we do this:\nstr_to_mask = { \"right\": 0x1, \"up_right\": 0x2, \"up_left\": 0x4, \"left\": 0x8, \"down_left\": 0x10, \"down_right\": 0x20 } function exits_to_mask(exit_array) -\u003e int mask = 0 for exit in exit_array: mask = mask | dirs_to_mask[exit] return mask The magic numbers are just the hexadecimal value of each bit being set (and only that bit).\nWhen stashing the road tile, we then use the mask for the key in the Dictionary, which will be a trivial lookup. (Aside: nearly $O(1)$ if you really want to know.)\nI said above that rotation is easy as well. If we’ve got an array of strings, we can’t just move the array contents around, we have to map each exit to the exit rotated one step around. The map is not slow itself (we can just have another lookup table), but in addition to all the string comparisons in the lookup table we need to walk all the exit array members.\nInstead, with the bitfield approach, we can rely on bit-shift operations to do the rotation, with a small bit of work to manage roll-over. Bit-shifting is often implemented in pure hardware, so it is reasonably efficient. Rotating the exit list each item is then just:\nfunction rotate_exits(mask) -\u003e int # shift all the exits along mask = mask \u003c\u003c 1 # pass the rollover bit to the bottom mask = mask | (mask \u0026 0x40 \u003e\u003e 5) # only keep the bits we're interested in mask = mask \u0026 0x3f # and return it return mask (Aside: most calculator apps will have a programmer mode that includes bit-shift and logical operations, which will show why this works.)\nGiven this, it’s fast to generate all the other road exit combinations for a given road piece, and to look up what piece we need for any combination.\nFor storage of road information, we mark tiles as having a road, and store the bitfield of exits. Adding a new road exit is purely doing a bit-wise OR on that exit in the tile. We also need to adjust the neighbour tile to reflect the connection back, but this is also a bit-wise OR.\nThis reduces our display effort to something very easy, just pull the road bitfield, look up that value in the index of all road pieces that are index by bitfield, and spawn the object in the correct place and rotation.\nEasy!\nKenney.nl Hexagon Kit ↩︎\n","wordCount":"1117","inLanguage":"en","datePublished":"2022-10-17T11:38:22+13:00","dateModified":"2022-10-17T11:38:22+13:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://dave2.github.io/post/hexagon-update-2022-10-17/"},"publisher":{"@type":"Organization","name":"Loosely Coherent Ramblings","logo":{"@type":"ImageObject","url":"https://dave2.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><header class=header><nav class=nav><div class=logo><a href=https://dave2.github.io/ accesskey=h title="Loosely Coherent Ramblings (Alt + H)">Loosely Coherent Ramblings</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dave2.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dave2.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://dave2.github.io/post/>Posts</a></div><h1 class=post-title>Hexagon Update: Roads</h1><div class=post-meta><span title='2022-10-17 11:38:22 +1300 +1300'>October 17, 2022</span></div></header><div class=post-content><p>As I mentioned in <a href=https://dave2.github.io/post/hexagon-update-2022-10-12/>some previous update</a>
I have been avoiding roads, although I have some theories on how to
make these work.</p><p>The first part of this however is just making roads appear in the
game world. The generation of roads is a bit pointless if I can&rsquo;t
see them. Also, I expect I&rsquo;ll need to do extensive debugging on road generation
and so I&rsquo;ll also need to see them.</p><p>The tileset I&rsquo;m using<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> has roads as separate models to be added to
the base tiles. The models cover all possible exit positions and
combinations, although they have been normalised so some combinations
and positions require rotating the model.</p><p><img loading=lazy src=preview-kenney.png alt="Preview of Kenney.nl&amp;rsquo;s Hexagon Tile Set"></p><p>You can see the road tiles towards the bottom left corner of the
image above (taken from Kenney.nl&rsquo;s website).</p><p>For all of the tiles I&rsquo;m using, I load these into the game based on
some metadata about the tile, using a simple JSON file containing a
list of the tiles and their metadata. For example, on the main tile
set I have a metadata index containing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;water&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;prefab_file&#34;</span>: <span style=color:#e6db74>&#34;Tiles/water.glb&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;tags&#34;</span>: [ <span style=color:#e6db74>&#34;water&#34;</span> ]
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;grass&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;prefab_file&#34;</span>: <span style=color:#e6db74>&#34;Tiles/grass.glb&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;tags&#34;</span>: [ <span style=color:#e6db74>&#34;grass&#34;</span> ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>(Aside: we actually read the metadata first and call <code>load()</code> on the
<code>prefab_file</code> specified here, which gives us scenes to instance into
the world. Everything is loaded into a <code>Dictionary</code> for easy access.)</p><p>The same approach is taken with road tiles, where we annotate what
exits a given road piece has:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>[
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;exits&#34;</span>: [ <span style=color:#e6db74>&#34;right&#34;</span>, <span style=color:#e6db74>&#34;left&#34;</span> ],
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;prefab_file&#34;</span>: <span style=color:#e6db74>&#34;Roads/path_straight.glb&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;exits&#34;</span>: [ <span style=color:#e6db74>&#34;right&#34;</span> ],
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;prefab_file&#34;</span>: <span style=color:#e6db74>&#34;Roads/path_start.glb&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>]</span></span></code></pre></div><p>As mentioned above, each road piece needs to be rotated to produce
all of the possible combinations. The <code>path_straight.glb</code> piece has
two other rotations available, 60 degrees should give us exits of
<code>[ "up_right", "down_left" ]</code>, and 120 should give us <code>[ "down_right", "up_left" ]</code>. (Probably, I haven&rsquo;t checked this is correct!)</p><p>In the first pass of this code, I just wrote out the combinations by
hand, adding a <code>"rotation"</code> field to the metadata. But I quickly found
this was cumbersome, more so when I got the exits for a given rotation
wrong (usually 0 degrees, so everything from there was wrong!).
Instead, we produce all of the other possible exit positions for a
road piece by iterating over the six different possible rotations and
rotating the exits at the same time.</p><p>At this point, it&rsquo;s useful to talk about how I resolve a tile having
a specific list of exits to a road piece. We need to ignore the order
the exits were provided in, and we need a fast way to look it up.</p><p>The naive implementation would be to stick all the exit combinations
into an array that points to the tile/rotation needed. Then we walk over
every element in the array of combinations, and then on each combination
(itself an array) we compare it to the array of exits we have.</p><p>This is slow, we&rsquo;re walking all possible combinations, and then also
doing a bunch of array walks and then string compares to compare the
exit arrays. Now, maybe this is premature, but there are faster
ways to do this.</p><p>Instead of storing the possible exits as an array of strings, we
convert them to a bitfield. This has a few advantages:</p><ul><li>It reduces the exits to a fixed order, regardless of how they
appear in the metadata</li><li>Bitfields are trivial to compare, they end up just as an <code>int</code></li><li>Using an <code>int</code> as a <code>Dictionary</code> key is fast and reliable</li><li>Rotating the exits is very easy in a bitfield</li></ul><p>Now some of my younger readers will be wondering why on earth I would
go deep into integer math to do this. Well, my programming roots
include a great deal of C (that&rsquo;s C, not C++, not C#) on microcontrollers,
and that space is all about bitfields. And one thing you learn quickly
in that space is when you have very few cycles, bitfields are very
efficient at solving a bunch of problems.</p><p>During import of the road pieces, we convert the exits array for a
piece into a bitfield. We do this by assigning a bit to each exit,
and the order of the bits corospond to going around the possible
rotations. In sort of psuedocode, we do this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>str_to_mask <span style=color:#f92672>=</span> { 
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;right&#34;</span>: <span style=color:#ae81ff>0x1</span>, <span style=color:#e6db74>&#34;up_right&#34;</span>: <span style=color:#ae81ff>0x2</span>, <span style=color:#e6db74>&#34;up_left&#34;</span>: <span style=color:#ae81ff>0x4</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;left&#34;</span>: <span style=color:#ae81ff>0x8</span>, <span style=color:#e6db74>&#34;down_left&#34;</span>: <span style=color:#ae81ff>0x10</span>, <span style=color:#e6db74>&#34;down_right&#34;</span>: <span style=color:#ae81ff>0x20</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function exits_to_mask(exit_array) <span style=color:#f92672>-&gt;</span> int
</span></span><span style=display:flex><span>    mask <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> exit <span style=color:#f92672>in</span> exit_array:
</span></span><span style=display:flex><span>        mask <span style=color:#f92672>=</span> mask <span style=color:#f92672>|</span> dirs_to_mask[exit]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mask</span></span></code></pre></div><p>The magic numbers are just the hexadecimal value of each bit being set
(and only that bit).</p><p>When stashing the road tile, we then use the mask for the key in the
<code>Dictionary</code>, which will be a trivial lookup. (Aside: nearly $O(1)$ if you
really want to know.)</p><p>I said above that rotation is easy as well. If we&rsquo;ve got an array of
strings, we can&rsquo;t just move the array contents around, we have to map
each exit to the exit rotated one step around. The map is not slow
itself (we can just have another lookup table), but in addition to all
the string comparisons in the lookup table we need to walk all the
exit array members.</p><p>Instead, with the bitfield approach, we can rely on bit-shift
operations to do the rotation, with a small bit of work to manage
roll-over. Bit-shifting is often implemented in pure hardware, so
it is reasonably efficient. Rotating the exit list each item is then just:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>function rotate_exits(mask) <span style=color:#f92672>-&gt;</span> int
</span></span><span style=display:flex><span>    <span style=color:#75715e># shift all the exits along</span>
</span></span><span style=display:flex><span>    mask <span style=color:#f92672>=</span> mask <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># pass the rollover bit to the bottom</span>
</span></span><span style=display:flex><span>    mask <span style=color:#f92672>=</span> mask <span style=color:#f92672>|</span> (mask <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x40</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># only keep the bits we&#39;re interested in</span>
</span></span><span style=display:flex><span>    mask <span style=color:#f92672>=</span> mask <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x3f</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># and return it</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mask</span></span></code></pre></div><p>(Aside: most calculator apps will have a programmer mode that includes
bit-shift and logical operations, which will show why this works.)</p><p>Given this, it&rsquo;s fast to generate all the other road exit combinations
for a given road piece, and to look up what piece we need for any
combination.</p><p>For storage of road information, we mark tiles as having a road, and
store the bitfield of exits. Adding a new road exit is purely
doing a bit-wise OR on that exit in the tile. We also need to adjust
the neighbour tile to reflect the connection back, but this is also
a bit-wise OR.</p><p>This reduces our display effort to something very easy, just pull the
road bitfield, look up that value in the index of all road pieces
that are index by bitfield, and spawn the object in the correct place
and rotation.</p><p>Easy!</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://kenney.nl/assets/hexagon-kit>Kenney.nl Hexagon Kit</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://dave2.github.io/tags/hexagon_game/>hexagon_game</a></li></ul><nav class=paginav><a class=prev href=https://dave2.github.io/post/hexagon-update-2022-10-18/><span class=title>« Prev</span><br><span>Hexagon Update: Roads .. again</span></a>
<a class=next href=https://dave2.github.io/post/hexagon-update-2022-10-13/><span class=title>Next »</span><br><span>Hexagon Game Update: The Past</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Hexagon Update: Roads on twitter" href="https://twitter.com/intent/tweet/?text=Hexagon%20Update%3a%20Roads&url=https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-17%2f&hashtags=hexagon_game"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hexagon Update: Roads on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-17%2f&title=Hexagon%20Update%3a%20Roads&summary=Hexagon%20Update%3a%20Roads&source=https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-17%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hexagon Update: Roads on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-17%2f&title=Hexagon%20Update%3a%20Roads"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hexagon Update: Roads on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-17%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hexagon Update: Roads on whatsapp" href="https://api.whatsapp.com/send?text=Hexagon%20Update%3a%20Roads%20-%20https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-17%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hexagon Update: Roads on telegram" href="https://telegram.me/share/url?text=Hexagon%20Update%3a%20Roads&url=https%3a%2f%2fdave2.github.io%2fpost%2fhexagon-update-2022-10-17%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://dave2.github.io/>Loosely Coherent Ramblings</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>