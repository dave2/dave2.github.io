<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hexagon Update: Roads | Loosely Coherent Ramblings</title><meta name=keywords content><meta name=description content="As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.
The first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can&rsquo;t see them. Also, I expect I&rsquo;ll need to do extensive debugging on road generation and so I&rsquo;ll also need to see them."><meta name=author content><link rel=canonical href=https://dave2.github.io/post/hexagon-update-2022-10-17/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://dave2.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dave2.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dave2.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://dave2.github.io/apple-touch-icon.png><link rel=mask-icon href=https://dave2.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="Hexagon Update: Roads"><meta property="og:description" content="As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.
The first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can&rsquo;t see them. Also, I expect I&rsquo;ll need to do extensive debugging on road generation and so I&rsquo;ll also need to see them."><meta property="og:type" content="article"><meta property="og:url" content="https://dave2.github.io/post/hexagon-update-2022-10-17/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-17T11:38:22+13:00"><meta property="article:modified_time" content="2022-10-17T11:38:22+13:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hexagon Update: Roads"><meta name=twitter:description content="As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.
The first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can&rsquo;t see them. Also, I expect I&rsquo;ll need to do extensive debugging on road generation and so I&rsquo;ll also need to see them."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dave2.github.io/post/"},{"@type":"ListItem","position":2,"name":"Hexagon Update: Roads","item":"https://dave2.github.io/post/hexagon-update-2022-10-17/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hexagon Update: Roads","name":"Hexagon Update: Roads","description":"As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.\nThe first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can\u0026rsquo;t see them. Also, I expect I\u0026rsquo;ll need to do extensive debugging on road generation and so I\u0026rsquo;ll also need to see them.","keywords":[],"articleBody":"As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.\nThe first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can’t see them. Also, I expect I’ll need to do extensive debugging on road generation and so I’ll also need to see them.\nThe tileset I’m using1 has roads as separate models to be added to the base tiles. The models cover all possible exit positions and combinations, although they have been normalised so some combinations and positions require rotating the model.\nYou can see the road tiles towards the bottom left corner of the image above (taken from Kenney.nl’s website).\nFor all of the tiles I’m using, I load these into the game based on some metadata about the tile, using a simple JSON file containing a list of the tiles and their metadata. For example, on the main tile set I have a metadata index containing:\n{ \"water\": { \"prefab_file\": \"Tiles/water.glb\", \"tags\": [ \"water\" ] }, \"grass\": { \"prefab_file\": \"Tiles/grass.glb\", \"tags\": [ \"grass\" ] } } (Aside: we actually read the metadata first and call load() on the prefab_file specified here, which gives us scenes to instance into the world. Everything is loaded into a Dictionary for easy access.)\nThe same approach is taken with road tiles, where we annotate what exits a given road piece has:\n[ { \"exits\": [ \"right\", \"left\" ], \"prefab_file\": \"Roads/path_straight.glb\" }, { \"exits\": [ \"right\" ], \"prefab_file\": \"Roads/path_start.glb\" } ] As mentioned above, each road piece needs to be rotated to produce all of the possible combinations. The path_straight.glb piece has two other rotations available, 60 degrees should give us exits of [ \"up_right\", \"down_left\" ], and 120 should give us [ \"down_right\", \"up_left\" ]. (Probably, I haven’t checked this is correct!)\nIn the first pass of this code, I just wrote out the combinations by hand, adding a \"rotation\" field to the metadata. But I quickly found this was cumbersome, more so when I got the exits for a given rotation wrong (usually 0 degrees, so everything from there was wrong!). Instead, we produce all of the other possible exit positions for a road piece by iterating over the six different possible rotations and rotating the exits at the same time.\nAt this point, it’s useful to talk about how I resolve a tile having a specific list of exits to a road piece. We need to ignore the order the exits were provided in, and we need a fast way to look it up.\nThe naive implementation would be to stick all the exit combinations into an array that points to the tile/rotation needed. Then we walk over every element in the array of combinations, and then on each combination (itself an array) we compare it to the array of exits we have.\nThis is slow, we’re walking all possible combinations, and then also doing a bunch of array walks and then string compares to compare the exit arrays. Now, maybe this is premature, but there are faster ways to do this.\nInstead of storing the possible exits as an array of strings, we convert them to a bitfield. This has a few advantages:\nIt reduces the exits to a fixed order, regardless of how they appear in the metadata Bitfields are trivial to compare, they end up just as an int Using an int as a Dictionary key is fast and reliable Rotating the exits is very easy in a bitfield Now some of my younger readers will be wondering why on earth I would go deep into integer math to do this. Well, my programming roots include a great deal of C (that’s C, not C++, not C#) on microcontrollers, and that space is all about bitfields. And one thing you learn quickly in that space is when you have very few cycles, bitfields are very efficient at solving a bunch of problems.\nDuring import of the road pieces, we convert the exits array for a piece into a bitfield. We do this by assigning a bit to each exit, and the order of the bits corospond to going around the possible rotations. In sort of psuedocode, we do this:\nstr_to_mask = { \"right\": 0x1, \"up_right\": 0x2, \"up_left\": 0x4, \"left\": 0x8, \"down_left\": 0x10, \"down_right\": 0x20 } function exits_to_mask(exit_array) -\u003e int mask = 0 for exit in exit_array: mask = mask | dirs_to_mask[exit] return mask The magic numbers are just the hexadecimal value of each bit being set (and only that bit).\nWhen stashing the road tile, we then use the mask for the key in the Dictionary, which will be a trivial lookup. (Aside: nearly $O(1)$ if you really want to know.)\nI said above that rotation is easy as well. If we’ve got an array of strings, we can’t just move the array contents around, we have to map each exit to the exit rotated one step around. The map is not slow itself (we can just have another lookup table), but in addition to all the string comparisons in the lookup table we need to walk all the exit array members.\nInstead, with the bitfield approach, we can rely on bit-shift operations to do the rotation, with a small bit of work to manage roll-over. Bit-shifting is often implemented in pure hardware, so it is reasonably efficient. Rotating the exit list each item is then just:\nfunction rotate_exits(mask) -\u003e int # shift all the exits along mask = mask \u003c\u003c 1 # pass the rollover bit to the bottom mask = mask | (mask \u0026 0x40 \u003e\u003e 5) # only keep the bits we're interested in mask = mask \u0026 0x3f # and return it return mask (Aside: most calculator apps will have a programmer mode that includes bit-shift and logical operations, which will show why this works.)\nGiven this, it’s fast to generate all the other road exit combinations for a given road piece, and to look up what piece we need for any combination.\nFor storage of road information, we mark tiles as having a road, and store the bitfield of exits. Adding a new road exit is purely doing a bit-wise OR on that exit in the tile. We also need to adjust the neighbour tile to reflect the connection back, but this is also a bit-wise OR.\nThis reduces our display effort to something very easy, just pull the road bitfield, look up that value in the index of all road pieces that are index by bitfield, and spawn the object in the correct place and rotation.\nEasy!\nKenney.nl Hexagon Kit ↩︎\n","wordCount":"1117","inLanguage":"en","datePublished":"2022-10-17T11:38:22+13:00","dateModified":"2022-10-17T11:38:22+13:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://dave2.github.io/post/hexagon-update-2022-10-17/"},"publisher":{"@type":"Organization","name":"Loosely Coherent Ramblings","logo":{"@type":"ImageObject","url":"https://dave2.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><header class=header><nav class=nav><div class=logo><a href=https://dave2.github.io/ accesskey=h title="Loosely Coherent Ramblings (Alt + H)">Loosely Coherent Ramblings</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Hexagon Update: Roads</h1><div class=post-meta><span title='2022-10-17 11:38:22 +1300 +1300'>October 17, 2022</span></div></header><div class=post-content><p>As I mentioned in <a href=https://dave2.github.io/post/hexagon-update-2022-10-12/>some previous update</a>
I have been avoiding roads, although I have some theories on how to
make these work.</p><p>The first part of this however is just making roads appear in the
game world. The generation of roads is a bit pointless if I can&rsquo;t
see them. Also, I expect I&rsquo;ll need to do extensive debugging on road generation
and so I&rsquo;ll also need to see them.</p><p>The tileset I&rsquo;m using<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> has roads as separate models to be added to
the base tiles. The models cover all possible exit positions and
combinations, although they have been normalised so some combinations
and positions require rotating the model.</p><p><img loading=lazy src=preview-kenney.png alt="Preview of Kenney.nl&amp;rsquo;s Hexagon Tile Set"></p><p>You can see the road tiles towards the bottom left corner of the
image above (taken from Kenney.nl&rsquo;s website).</p><p>For all of the tiles I&rsquo;m using, I load these into the game based on
some metadata about the tile, using a simple JSON file containing a
list of the tiles and their metadata. For example, on the main tile
set I have a metadata index containing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;water&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;prefab_file&#34;</span>: <span style=color:#e6db74>&#34;Tiles/water.glb&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;tags&#34;</span>: [ <span style=color:#e6db74>&#34;water&#34;</span> ]
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;grass&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;prefab_file&#34;</span>: <span style=color:#e6db74>&#34;Tiles/grass.glb&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;tags&#34;</span>: [ <span style=color:#e6db74>&#34;grass&#34;</span> ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>(Aside: we actually read the metadata first and call <code>load()</code> on the
<code>prefab_file</code> specified here, which gives us scenes to instance into
the world. Everything is loaded into a <code>Dictionary</code> for easy access.)</p><p>The same approach is taken with road tiles, where we annotate what
exits a given road piece has:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>[
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;exits&#34;</span>: [ <span style=color:#e6db74>&#34;right&#34;</span>, <span style=color:#e6db74>&#34;left&#34;</span> ],
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;prefab_file&#34;</span>: <span style=color:#e6db74>&#34;Roads/path_straight.glb&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;exits&#34;</span>: [ <span style=color:#e6db74>&#34;right&#34;</span> ],
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;prefab_file&#34;</span>: <span style=color:#e6db74>&#34;Roads/path_start.glb&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>]</span></span></code></pre></div><p>As mentioned above, each road piece needs to be rotated to produce
all of the possible combinations. The <code>path_straight.glb</code> piece has
two other rotations available, 60 degrees should give us exits of
<code>[ "up_right", "down_left" ]</code>, and 120 should give us <code>[ "down_right", "up_left" ]</code>. (Probably, I haven&rsquo;t checked this is correct!)</p><p>In the first pass of this code, I just wrote out the combinations by
hand, adding a <code>"rotation"</code> field to the metadata. But I quickly found
this was cumbersome, more so when I got the exits for a given rotation
wrong (usually 0 degrees, so everything from there was wrong!).
Instead, we produce all of the other possible exit positions for a
road piece by iterating over the six different possible rotations and
rotating the exits at the same time.</p><p>At this point, it&rsquo;s useful to talk about how I resolve a tile having
a specific list of exits to a road piece. We need to ignore the order
the exits were provided in, and we need a fast way to look it up.</p><p>The naive implementation would be to stick all the exit combinations
into an array that points to the tile/rotation needed. Then we walk over
every element in the array of combinations, and then on each combination
(itself an array) we compare it to the array of exits we have.</p><p>This is slow, we&rsquo;re walking all possible combinations, and then also
doing a bunch of array walks and then string compares to compare the
exit arrays. Now, maybe this is premature, but there are faster
ways to do this.</p><p>Instead of storing the possible exits as an array of strings, we
convert them to a bitfield. This has a few advantages:</p><ul><li>It reduces the exits to a fixed order, regardless of how they
appear in the metadata</li><li>Bitfields are trivial to compare, they end up just as an <code>int</code></li><li>Using an <code>int</code> as a <code>Dictionary</code> key is fast and reliable</li><li>Rotating the exits is very easy in a bitfield</li></ul><p>Now some of my younger readers will be wondering why on earth I would
go deep into integer math to do this. Well, my programming roots
include a great deal of C (that&rsquo;s C, not C++, not C#) on microcontrollers,
and that space is all about bitfields. And one thing you learn quickly
in that space is when you have very few cycles, bitfields are very
efficient at solving a bunch of problems.</p><p>During import of the road pieces, we convert the exits array for a
piece into a bitfield. We do this by assigning a bit to each exit,
and the order of the bits corospond to going around the possible
rotations. In sort of psuedocode, we do this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>str_to_mask <span style=color:#f92672>=</span> { 
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;right&#34;</span>: <span style=color:#ae81ff>0x1</span>, <span style=color:#e6db74>&#34;up_right&#34;</span>: <span style=color:#ae81ff>0x2</span>, <span style=color:#e6db74>&#34;up_left&#34;</span>: <span style=color:#ae81ff>0x4</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;left&#34;</span>: <span style=color:#ae81ff>0x8</span>, <span style=color:#e6db74>&#34;down_left&#34;</span>: <span style=color:#ae81ff>0x10</span>, <span style=color:#e6db74>&#34;down_right&#34;</span>: <span style=color:#ae81ff>0x20</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function exits_to_mask(exit_array) <span style=color:#f92672>-&gt;</span> int
</span></span><span style=display:flex><span>    mask <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> exit <span style=color:#f92672>in</span> exit_array:
</span></span><span style=display:flex><span>        mask <span style=color:#f92672>=</span> mask <span style=color:#f92672>|</span> dirs_to_mask[exit]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mask</span></span></code></pre></div><p>The magic numbers are just the hexadecimal value of each bit being set
(and only that bit).</p><p>When stashing the road tile, we then use the mask for the key in the
<code>Dictionary</code>, which will be a trivial lookup. (Aside: nearly $O(1)$ if you
really want to know.)</p><p>I said above that rotation is easy as well. If we&rsquo;ve got an array of
strings, we can&rsquo;t just move the array contents around, we have to map
each exit to the exit rotated one step around. The map is not slow
itself (we can just have another lookup table), but in addition to all
the string comparisons in the lookup table we need to walk all the
exit array members.</p><p>Instead, with the bitfield approach, we can rely on bit-shift
operations to do the rotation, with a small bit of work to manage
roll-over. Bit-shifting is often implemented in pure hardware, so
it is reasonably efficient. Rotating the exit list each item is then just:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>function rotate_exits(mask) <span style=color:#f92672>-&gt;</span> int
</span></span><span style=display:flex><span>    <span style=color:#75715e># shift all the exits along</span>
</span></span><span style=display:flex><span>    mask <span style=color:#f92672>=</span> mask <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># pass the rollover bit to the bottom</span>
</span></span><span style=display:flex><span>    mask <span style=color:#f92672>=</span> mask <span style=color:#f92672>|</span> (mask <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x40</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># only keep the bits we&#39;re interested in</span>
</span></span><span style=display:flex><span>    mask <span style=color:#f92672>=</span> mask <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x3f</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># and return it</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mask</span></span></code></pre></div><p>(Aside: most calculator apps will have a programmer mode that includes
bit-shift and logical operations, which will show why this works.)</p><p>Given this, it&rsquo;s fast to generate all the other road exit combinations
for a given road piece, and to look up what piece we need for any
combination.</p><p>For storage of road information, we mark tiles as having a road, and
store the bitfield of exits. Adding a new road exit is purely
doing a bit-wise OR on that exit in the tile. We also need to adjust
the neighbour tile to reflect the connection back, but this is also
a bit-wise OR.</p><p>This reduces our display effort to something very easy, just pull the
road bitfield, look up that value in the index of all road pieces
that are index by bitfield, and spawn the object in the correct place
and rotation.</p><p>Easy!</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://kenney.nl/assets/hexagon-kit>Kenney.nl Hexagon Kit</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://dave2.github.io/>Loosely Coherent Ramblings</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>