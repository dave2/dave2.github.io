<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hexagon Update: Roads .. again | Loosely Coherent Ramblings</title><meta name=keywords content><meta name=description content="Well, it wouldn&rsquo;t be my code development if any design pattern lasted longer than four hours! In fact, in the previous post it omits the details this was actually the second pass, where we stored masks in the tile data directly, rather than in a different set of dictionaries.
But, before tackling changing everything again, I did get to a better place about how to draw roads on the map. Not the display part now, the actual &ldquo;draw road from A to B&rdquo; including all the steps needed to join them."><meta name=author content><link rel=canonical href=https://dave2.github.io/post/hexagon-update-2022-10-18/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://dave2.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dave2.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dave2.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://dave2.github.io/apple-touch-icon.png><link rel=mask-icon href=https://dave2.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Hexagon Update: Roads .. again"><meta property="og:description" content="Well, it wouldn&rsquo;t be my code development if any design pattern lasted longer than four hours! In fact, in the previous post it omits the details this was actually the second pass, where we stored masks in the tile data directly, rather than in a different set of dictionaries.
But, before tackling changing everything again, I did get to a better place about how to draw roads on the map. Not the display part now, the actual &ldquo;draw road from A to B&rdquo; including all the steps needed to join them."><meta property="og:type" content="article"><meta property="og:url" content="https://dave2.github.io/post/hexagon-update-2022-10-18/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-18T15:47:47+13:00"><meta property="article:modified_time" content="2022-10-18T15:47:47+13:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hexagon Update: Roads .. again"><meta name=twitter:description content="Well, it wouldn&rsquo;t be my code development if any design pattern lasted longer than four hours! In fact, in the previous post it omits the details this was actually the second pass, where we stored masks in the tile data directly, rather than in a different set of dictionaries.
But, before tackling changing everything again, I did get to a better place about how to draw roads on the map. Not the display part now, the actual &ldquo;draw road from A to B&rdquo; including all the steps needed to join them."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dave2.github.io/post/"},{"@type":"ListItem","position":2,"name":"Hexagon Update: Roads .. again","item":"https://dave2.github.io/post/hexagon-update-2022-10-18/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hexagon Update: Roads .. again","name":"Hexagon Update: Roads .. again","description":"Well, it wouldn\u0026rsquo;t be my code development if any design pattern lasted longer than four hours! In fact, in the previous post it omits the details this was actually the second pass, where we stored masks in the tile data directly, rather than in a different set of dictionaries.\nBut, before tackling changing everything again, I did get to a better place about how to draw roads on the map. Not the display part now, the actual \u0026ldquo;draw road from A to B\u0026rdquo; including all the steps needed to join them.","keywords":[],"articleBody":"Well, it wouldn’t be my code development if any design pattern lasted longer than four hours! In fact, in the previous post it omits the details this was actually the second pass, where we stored masks in the tile data directly, rather than in a different set of dictionaries.\nBut, before tackling changing everything again, I did get to a better place about how to draw roads on the map. Not the display part now, the actual “draw road from A to B” including all the steps needed to join them.\nPathfinding is a well trodden area in game design. There’s a bunch of methods, but the A* algorithm fits my needs pretty well. This involves building a graph of nodes connected by edges, and assigning weights or costs or whatever you want to call it to traversing the node or edge.\nI was thinking I might have to build A* myself in GDscript but what’s this? Oh, Godot already includes A* classes to do all the work for me. Well, most of the work anyway, the traversal bit anyway. In Godot 4 we actually get three different versions of A*, mostly separated by the node elements.\nBecause we’re doing pathfinding on a 2D plane1 we’ll use the AStar2D class for our pathfinding. This provides two virtual methods we will need to replace, _compute_cost() and _estimate_cost() which given two points returns the exact or lower-bound cost of the path between the two points.\nWe have to overide those as we want our costs based on axial coordinate distances, not cartesian coordinates for the tiles themselves. And the AStar2D wants nodes with cartesian coordinates (specifically, it expects Vector2 coordinates). I should point out, this is noted in the Red Blog Games Hexagon Guide about Pathfinding, and is not something I’ve pulled out of skill or knowledge myself!\nAs we have a grid of tiles (albeit a hexagon grid), we’ll just throw a graph containing a node for every tile, and connections from each node to all neighbours that meet appropriate criteria (mostly, can put a road on it!)\nAt this point, the current implementation and the one I want to move to changes a bit. I’ve added costs to the metadata about tile types, as we’re applying something simple as a policy: tiles like grass are easy to move on, tiles like forests and mountains are harder but not impossible, and water should be impossible .. for now.\nI am making forests and mountains hard but not impossible to produce roads that tend to avoid these obstacles rather than plow through them, but will plow through them when there’s little choice but to make a very large detour around them. I think this will produce a pleasing balance between direct straight line roads and roads which have nice natural curves and meandering.\nAs it happens, building the graph the AStar2D class needs is remarkably easy. When we create a new tile (using the badly named set_tile()) we generate the point index the graph wants and store it with the tile. Then in update_tile() (which gets called either directly or by set_tile()) we add/update the point in the graph with the cost of that type of tile. This means when we change tiles we also update the costs in the graph of the tile.\nHowever, we also need to maintain the graph, so we do this in update_tile() as well. We also need to remove the point if the tile is no longer navigable, and connect or disconnect points in the graph as well. For connecting and disconnecting points, we walk our neighbours and check if they are appropriate to move into, and then add these appropriate connections.\nIn psuedo-code, for each tile we update it looks like:\nif updating tile: if tile_type is allowed road: add/update this point in graph for each neighbour: if neighbour is allowed road: add connection between this tile and neighbour tile else: remove connection between this tile and neighbour tile else: for each neighbour: remove connection between this tile and neighbour tile remove point from graph Once we have the graph with nodes, we can ask it for the path between two points. Because the AStar2D class expects point indexes, there’s a bunch of translation back and forth between axial coordinates of tiles and the point index. But, that’s fairly quick and thus we have roads which look more natural:\nI said there were things I wanted to change, and in writing this down plus the development issues, I think it will be reworked a bit very shortly.\nThe first problem is that as road pieces are expected to sit on a tile, they clash with some tiles. Forests, for example, don’t really look so good with a road going through them because the trees on the tile look like they’re on the road. To work around that, the current version just forces the tile to grass if it was forest before.\nThe other problem is water. Water is currently not allowed for traversal. It makes no sense, it’s a road, not a boat. How this is going to be managed is uncertain, but it’ll have to be some how. The map may end up with a slice of water dividing it in two and without any way of generating a road between the two sides.\nBut these are problems for another day.\nThe world is a flat plane even if we were to jazz it up a bit with tiles at different heights. That is, the player can’t decide to go up or down within a tile, they can only go to whatever height the tile is. So all our positions are 2D, thus navigation is on a 2D plane. ↩︎\n","wordCount":"955","inLanguage":"en","datePublished":"2022-10-18T15:47:47+13:00","dateModified":"2022-10-18T15:47:47+13:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://dave2.github.io/post/hexagon-update-2022-10-18/"},"publisher":{"@type":"Organization","name":"Loosely Coherent Ramblings","logo":{"@type":"ImageObject","url":"https://dave2.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dave2.github.io/ accesskey=h title="Loosely Coherent Ramblings (Alt + H)">Loosely Coherent Ramblings</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Hexagon Update: Roads .. again</h1><div class=post-meta><span title='2022-10-18 15:47:47 +1300 +1300'>October 18, 2022</span></div></header><div class=post-content><p>Well, it wouldn&rsquo;t be my code development if any design pattern lasted
longer than four hours! In fact, in the <a href=https://dave2.github.io/post/hexagon-update-2022-10-17/>previous post</a>
it omits the details this was actually the second pass, where we
stored masks in the tile data directly, rather than in a different
set of dictionaries.</p><p>But, before tackling changing everything again, I did get to a better
place about how to draw roads on the map. Not the display part now,
the actual &ldquo;draw road from A to B&rdquo; including all the steps needed
to join them.</p><p>Pathfinding is a well trodden area in game design. There&rsquo;s a bunch of
methods, but the <a href=https://en.wikipedia.org/wiki/A*_search_algorithm>A* algorithm</a> fits my needs pretty well. This involves
building a graph of nodes connected by edges, and assigning weights or
costs or whatever you want to call it to traversing the node or edge.</p><p>I was thinking I might have to build A* myself in GDscript but what&rsquo;s
this? Oh, Godot already includes A* classes to do all the work for me.
Well, most of the work anyway, the traversal bit anyway. In Godot 4
we actually get three different versions of A*, mostly separated by
the node elements.</p><p>Because we&rsquo;re doing pathfinding on a 2D plane<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> we&rsquo;ll use the <code>AStar2D</code>
class for our pathfinding. This provides two virtual methods we will
need to replace, <code>_compute_cost()</code> and <code>_estimate_cost()</code> which given
two points returns the exact or lower-bound cost of the path between
the two points.</p><p>We have to overide those as we want our costs based on axial coordinate
distances, not cartesian coordinates for the tiles themselves. And
the <code>AStar2D</code> wants nodes with cartesian coordinates (specifically, it
expects <code>Vector2</code> coordinates). I should point out, this is noted in
the Red Blog Games Hexagon Guide about <a href=https://www.redblobgames.com/grids/hexagons/#pathfinding>Pathfinding</a>,
and is not something I&rsquo;ve pulled out of skill or knowledge myself!</p><p>As we have a grid of tiles (albeit a hexagon grid), we&rsquo;ll just throw
a graph containing a node for every tile, and connections from each
node to all neighbours that meet appropriate criteria (mostly, can put
a road on it!)</p><p>At this point, the current implementation and the one I want to move
to changes a bit. I&rsquo;ve added costs to the metadata about tile types,
as we&rsquo;re applying something simple as a policy: tiles like grass
are easy to move on, tiles like forests and mountains are harder but
not impossible, and water should be impossible .. for now.</p><p>I am making forests and mountains hard but not impossible to produce
roads that tend to avoid these obstacles rather than plow through them,
but will plow through them when there&rsquo;s little choice but to make a
very large detour around them. I think this will produce a pleasing
balance between direct straight line roads and roads which have nice
natural curves and meandering.</p><p>As it happens, building the graph the <code>AStar2D</code> class needs is
remarkably easy. When we create a new tile (using the badly named
<code>set_tile()</code>) we generate the point index the graph wants and store
it with the tile. Then in <code>update_tile()</code> (which gets called either
directly or by <code>set_tile()</code>) we add/update the point in the graph
with the cost of that type of tile. This means when we change tiles
we also update the costs in the graph of the tile.</p><p>However, we also need to maintain the graph, so we do this in <code>update_tile()</code>
as well. We also need to remove the point if the tile is no longer
navigable, and connect or disconnect points in the graph as well. For
connecting and disconnecting points, we walk our neighbours and check
if they are appropriate to move into, and then add these appropriate
connections.</p><p>In psuedo-code, for each tile we update it looks like:</p><pre tabindex=0><code class=language-nohighlight data-lang=nohighlight>if updating tile:
    if tile_type is allowed road:
        add/update this point in graph
        for each neighbour:
            if neighbour is allowed road:
                add connection between this tile and neighbour tile
            else:
                remove connection between this tile and neighbour tile
    else:
        for each neighbour:
            remove connection between this tile and neighbour tile
        remove point from graph</code></pre><p>Once we have the graph with nodes, we can ask it for the path between
two points. Because the <code>AStar2D</code> class expects point indexes, there&rsquo;s
a bunch of translation back and forth between axial coordinates of
tiles and the point index. But, that&rsquo;s fairly quick and thus we have
roads which look more natural:</p><p><img loading=lazy src=its-a-road.jpg alt="A generated road on the Hexmap"></p><p>I said there were things I wanted to change, and in writing this down
plus the development issues, I think it will be reworked a bit very
shortly.</p><p>The first problem is that as road pieces are expected to sit on a
tile, they clash with some tiles. Forests, for example, don&rsquo;t really
look so good with a road going through them because the trees on the
tile look like they&rsquo;re on the road. To work around that, the
current version just forces the tile to grass if it was forest before.</p><p>The other problem is water. Water is currently not allowed for
traversal. It makes no sense, it&rsquo;s a road, not a boat. How this
is going to be managed is uncertain, but it&rsquo;ll have to be some
how. The map may end up with a slice of water dividing it in two
and without any way of generating a road between the two sides.</p><p>But these are problems for another day.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The world is a flat plane even if we were to jazz it up a bit
with tiles at different heights. That is, the player can&rsquo;t decide
to go up or down within a tile, they can only go to whatever height
the tile is. So all our positions are 2D, thus navigation is on a
2D plane.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://dave2.github.io/>Loosely Coherent Ramblings</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>