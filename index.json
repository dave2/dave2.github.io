[{"content":"Ah it\u0026rsquo;s been a while, what\u0026rsquo;s been going on?\nAndroid using OpenGL3 compat So as of Godot 4.0 beta 7, you can re-enable opengl3 as a rendering engine for Godot builds. Great! This is actually the first time I think I\u0026rsquo;ve had the game running on my phone at all.\nThe good news is it looks about what I\u0026rsquo;d expect, except buttons are a little on the small side. But it\u0026rsquo;s very very slow (esp refreshing the display) so this seems to be a mix of opengl3 being very rough at this point in the Godot 4 cycle and simply the fact my phone ain\u0026rsquo;t my PC when it comes to the lifting.\nThe opengl3 engine isn\u0026rsquo;t really expected to be any good in 4.0 and it\u0026rsquo;s not expected to be properly good until sometime later in the 4.x cycle so this isn\u0026rsquo;t unexpected at all.\nThe other apsect which didn\u0026rsquo;t work at all is GUI control input from touch. I have \u0026ldquo;Emulate mouse from touch\u0026rdquo; enabled which should be all that\u0026rsquo;s required but either there\u0026rsquo;s some other major problem stemming from the not fully cooked opengl3 renderer, or I have a real problem with input in Android.\nAnyway, hopefully the last remaining Vulkan rendering bug preventing the game running at all on Vulkan on mobile will be fixed soon, and then we shall see what the real causes are!\nDialog and Quests Both of these systems are ones which I am not particularly familar with in how to approach them. However, the basic dialog frame with player input works. It doesn\u0026rsquo;t have next-page buttons like it should, but that\u0026rsquo;s not too difficult to work on.\nAt the same time, there is rudimentary support for recognising that places in the world can be entered and therefore ask about this. This needs a better indication, as we shouldn\u0026rsquo;t use the classic quest exclamation mark to mean \u0026ldquo;enterable\u0026rdquo;, like shops are not quest points right?\nThe quest plan itself is roughly bullt in terms of what classes will do what. There\u0026rsquo;s a QuestPlan which contains the whole set of steps for this quest, and where we are up to, and it holds at start point and rewards and description for the overall quest. This also stashes an array of QuestObjective and each of these are our requirements to meet. Go talk to people, get objects, kill stuff.. those are steps.\nThe data model looks okay, but it needs a lot of filling out of the actual quest generation and objective handling. But baby steps. These are the third and second most difficult parts of the game I have to implement. (The most difficult is combat!)\nGUI work I\u0026rsquo;ve also been fixing up the UI here and there, and trying to make it look a lot more game-like. I\u0026rsquo;m still using the main Godot GUI components and it turns out that I can theme them much more than I thought was actually realistic to do so. Now I have much more richly-themeed components I can use instead of layering a bunch of controls and 2D elements to fake it.\nWrapping up Progress is very slow (slower than it\u0026rsquo;s ever been), but I\u0026rsquo;m chipping away at the code as best I can, while the beta releases of Godot truck on. Apart from some colour lookup issues, and FileAccess API rework that landed in beta 5 and beta 3 respectively, it\u0026rsquo;s been remarkably smooth sailing in the beta releases so far, so I\u0026rsquo;m pretty happy about how things have been going.\nCherry-O!\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-12-02/","summary":"Ah it\u0026rsquo;s been a while, what\u0026rsquo;s been going on?\nAndroid using OpenGL3 compat So as of Godot 4.0 beta 7, you can re-enable opengl3 as a rendering engine for Godot builds. Great! This is actually the first time I think I\u0026rsquo;ve had the game running on my phone at all.\nThe good news is it looks about what I\u0026rsquo;d expect, except buttons are a little on the small side. But it\u0026rsquo;s very very slow (esp refreshing the display) so this seems to be a mix of opengl3 being very rough at this point in the Godot 4 cycle and simply the fact my phone ain\u0026rsquo;t my PC when it comes to the lifting.","title":"Hexagon Update: 2 Dec 2022"},{"content":"Things have been a bit slow in the last few days. But, still making some progress even if I\u0026rsquo;ve been distracted into rabbit holes.\nInventory After reworking all the inventory code to separate equip slots on the player from what an item knows about where it can be equipped, the last part was correctly wiring up the actual inventory storage on the player.\nOne problem not mentioned in previous posts is Godot 4 still has some bugs in places, which is not unexpected given it\u0026rsquo;s still only Beta. The inventory save/load was getting hung up on a serialisation bug in store_var() and get_var(), which write and read any variable type to and from files.\nThe deserialisation is choking on some aspect of the type of variable I was passing, specifically a class object that mostly just stores things and has a few functions attached. This meant I had to manually serialise and deserialise the class in the save/load code.\nIt\u0026rsquo;s done now, it\u0026rsquo;s ugly, but it gets us moving forward.\nI also cleaned up the handling of TWOHAND items so it correctly locks the off-hand slot when this type of item is equipped.\nThe inventory is largely done. The only things missing are a summary of equipped effects (at least passive effects) and enumerating all the icons for inventory items. I have a large collection of icons from a paid source and I need to index them and do things like assign them some attributes like weight or style.\nQuests While Inventory isn\u0026rsquo;t completely done, I started to work out what quests is going to look like. The first problem is actually we need a way of showing in-game there is a quest on a particular tile.\nThis would be the classic yellow exclamation mark or question mark. The universal symbol for \u0026ldquo;quest\u0026rdquo;. I wanted to make these stand out on the world so they need a glow and they need to move.\nI built a \u0026ldquo;quest indicator\u0026rdquo; prefab consisting of both types of indicator with a way to ask for the one desired, and added an animation player and track for making them spin. For simplicity, we just spin both of the indicators even if only one is visible.\nThe tile decoration data was also modified to include an offset for the quest indicator, so it would be placed just above any decoration on the tile. This has be done per-decoration so they look associated with the decoration.\nThe indicator itself I was going to make a 3D model for, but as it happens there\u0026rsquo;s support for 3D extruded text in Godot, so the indicator models are just that.\nThe question mark looked wrong when spinning, due to the pivot point being offset from the dot at the bottom. It looked better to have the dot spin in-place and the rest of the symbol around it. This involved just layering a bunch of Node3D to apply an offset and then spinning the parent of the layers.\nLastly, the markers needed something more to make them stand out, so I looked at how to make them glow. This is not obvious how to do within the default shaders in Godot. The method involves changing the World Environment resource to have glow enabled, and tweaking the hdr_threshold for when to have the object glow. Then any object with a material that has any albedo above the threshold will glow.. which counter-intuitively to me was where R, G, or B was higher than 1.0. Hence, \u0026ldquo;HDR\u0026rdquo; mentioned before.\nAnyway, that kinda worked. It looks washed out but glowing and that\u0026rsquo;s good enough.\nThis leads into..\nShowing the player I\u0026rsquo;ve struggled with how to show the player in the world. At times I thought it would be best to have an actual player model (maybe based on something the player chose) but the design of the tiles doesn\u0026rsquo;t always suit that.\nFor now I\u0026rsquo;ve settled on having a player-determined banner representing their position in the world. This is just a bunch of Sprite3D layers with different PNGs build in Inkscape, but it\u0026rsquo;ll do for now.\nThe banner is set to overdraw always, which makes it look a little odd when you move behind very tall objects. But if it wasn\u0026rsquo;t set to overdraw everything, it looks even worse when place on top of very tall objects.\nIt\u0026rsquo;s just a compromise I\u0026rsquo;ll have to accept.\nNext goals Next up will be a few more things around quests and the player:\nBuild the new game menus to include player names, world seed, and banner building. Build a quest UI for the current set of taken quests. On-screen quest tracker Implement a proper data model for quests that exist and are placed in the world I\u0026rsquo;m also likely to start reskinning some of the UI elements to be more game-like. They are still too much default out of the box elements.\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-11-21/","summary":"Things have been a bit slow in the last few days. But, still making some progress even if I\u0026rsquo;ve been distracted into rabbit holes.\nInventory After reworking all the inventory code to separate equip slots on the player from what an item knows about where it can be equipped, the last part was correctly wiring up the actual inventory storage on the player.\nOne problem not mentioned in previous posts is Godot 4 still has some bugs in places, which is not unexpected given it\u0026rsquo;s still only Beta.","title":"Hexagon Update 21 Nov 2022"},{"content":"Well hi there folks. Not sure anyone is reading this, but that\u0026rsquo;s just fine, it\u0026rsquo;s more for my mental well-being than anything else. Let\u0026rsquo;s dive into the state of things.\nInventory Most of the last week has been on nothing but Inventory and getting both the basic UI, data, and storage sorted out.\nUnexpectedly, building the UI still goes somewhat okay. There\u0026rsquo;s still a huge problem in my head between where the UI is doing things, and whether things like validation of what can be placed where live in the UI (where, actually, they get called a lot) or somewhere else.\nAt the moment there is some uncomfortable duplication. What should really be taking place is the Inventory UI is a view of the data, not populated with it\u0026rsquo;s own set of the items in every slot. However, from the way the UI is structure, it is much easier to poke items into a slot in the UI and have the UI render that, than tell the slot in the UI how to find out what it\u0026rsquo;s contents might be.\nIt\u0026rsquo;s also getting pretty deep in layers of callbacks to deal with changes. This is where the way it\u0026rsquo;s being implemented is starting to break down.\nThe reason is we\u0026rsquo;re using Godot\u0026rsquo;s built-in UI features and these mostly fire signals at our top-level elements. In the inventory case there is an invisible button on top of every slot which gets these events.\nNow that makes it easy to capture events - no math needed to convert positional information to identify the slot picked - but we have to then look more at callbacks to make it come together with state the individual button isn\u0026rsquo;t holding.\nAnyway, some gamedev will be screaming at the page now going \u0026ldquo;just do it \u0026lt;this way\u0026gt;\u0026rdquo; and they\u0026rsquo;ll be right. But I\u0026rsquo;m feeling out all of this from first principles right?\nWe\u0026rsquo;re already on a major rewrite of how inventory is stored, so maybe I should finish that before starting a new rewrite?\nThat current rewrite was triggered by a deeply flawed decision to have separate variables holding equipped from just stored items. This resulted in doubling all the functions, and I used strings for equipment slots and ints for normal storage. And then I mixed up the slots an item may be stashed in with slots we actually have.\nThat last point is based on items that either span multiple slots or can be used in multiple slots. So we have a TWOHAND equip slot on items .. but that doesn\u0026rsquo;t exist in the inventory. Building all the data structures on what items were using as slots was all sorts of wrong, but I didn\u0026rsquo;t see that until quite late.\nSo it\u0026rsquo;s all been rewritten, equipment slots are now just low-numbered inventory slots, and we special case them when testing for accepting or stashing an item.\nThe good news is, because I\u0026rsquo;m just using Godot\u0026rsquo;s internal drag and drop I have drag and drop working, you can move items around the inventory, and drag them in and out of equipment slots, and it even tests if this is an acceptable move. Hooray.\nAfter I do another rewrite I need to add support for stacking and unstacking items. The item class already has stack properties, and the UI already has support for showing stacked items, but none of this is actually wired up. And once stacking is done then it\u0026rsquo;s on to looting UI and shop UI!\nThis stacking thing shouldn\u0026rsquo;t be too hard, he said having realised actually it is hard because items don\u0026rsquo;t have a concept of equality. Huh.\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-11-15/","summary":"Well hi there folks. Not sure anyone is reading this, but that\u0026rsquo;s just fine, it\u0026rsquo;s more for my mental well-being than anything else. Let\u0026rsquo;s dive into the state of things.\nInventory Most of the last week has been on nothing but Inventory and getting both the basic UI, data, and storage sorted out.\nUnexpectedly, building the UI still goes somewhat okay. There\u0026rsquo;s still a huge problem in my head between where the UI is doing things, and whether things like validation of what can be placed where live in the UI (where, actually, they get called a lot) or somewhere else.","title":"Hexagon Update: 15 Nov 2022"},{"content":"World View and Gen The world view needed one more piece of polish before I really need to get on with some of the other systems in the game. While I do want to enrich the world generation with villages and more POI, that\u0026rsquo;s something which can easily come later.\nIn the monthly update, I mentioned that the world needs some sort of fog system for unexplored tiles. I played around with a few different methods, but in the end it actually was easiest to just use Sprite3D set at an appropriate height, with some noise-based colouring and alpha for edges. To avoid needing to deal with different terrain heights, the Sprite3D was marked as skipping depth test, so simply overdraws without taking into account the actual Z value for the cloud object.\nThe result is fairly reasonable in the end:\nPutting aside the basic world view I think is really needed or I will forever be fiddling with the way it looks and is generated, and never get on with other parts of the game.\nInventory The first step to any combat, quest, or other system is going to be items. We need to have items in the game for combat reasons, as part of quests, and likely a bunch of other things. For the first time while developing this game, I did a quick hand drawn mock up of what the Inventory screen should look like:\nThis concept has the panel divided into three broad areas. The left is the equipped, the middle the main inventory, and the right has a panel for the item selected. It\u0026rsquo;s slightly different to how an inventory might work on a PC game, specifically around how to do item comparisons.\nMost of the time if you get a new item, you want to know if it\u0026rsquo;s better or worse than an existing item. This is so common a need that games which don\u0026rsquo;t have it and allow modding almost certainly have a mod which allows instant comparisons on hover.\nWe can\u0026rsquo;t really do things like comparison on hover, so instead the panel on the right is both displaying the details about an item and includes some instant comparisons against the currently equipped item. That way, you can just tap the item in the inventory to get both details and if this item is better than the current one you have on.\nFor the middle panel, I\u0026rsquo;ve gone with a fixed 4x4 grid for 16 slots. Rather then implement any complex logic like weight or volume or items spanning multiple cells, I\u0026rsquo;ve gone with a plain dumb one item one slot deal. No weight limits or stuff, you can carry a bus if we had a bus item. This is intended to be a casual game, inventory management as a whole mini-game is something that I personally find annoying anyway.\nBelow the main grid is some slots for bags. I\u0026rsquo;m still uncertain if I\u0026rsquo;ll implement this, or just make the main grid bigger. THe intent anyway is each bag slot when populated with a bag unlocks another 4x4 panel. It\u0026rsquo;s dumb but it\u0026rsquo;ll work fine.\nEquipping will be done by dragging items out of the inventory to the equip space. This will actually free up the slot in the inventory space (we\u0026rsquo;re not going to make you have equipped items also in your inventory).\nAnyway, that\u0026rsquo;s the plan. The first early attempts at building this have gone okay so far:\nThe background of any inventory slot will be coloured by item quality, as I prefer having an easy visual guide for junk vs awesome, more so once we implement shops and looting. It has a space for the stack amount for stackable items, and placeholders for a bunch of other things.\nItem Data At the same time, I\u0026rsquo;ve started out the item data itself. I\u0026rsquo;m still fleshing out some details. I like items having a quality, but I\u0026rsquo;m unsure if I want a level as well (which influences range of stats I guess?).\nI think stats and effects will just be a single array of Things This Has and we process it for stats and effects when drawing the item detail panel.\nBut at the moment, the item data is pretty basic. It shall be filled out soon enough.\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-11-10/","summary":"World View and Gen The world view needed one more piece of polish before I really need to get on with some of the other systems in the game. While I do want to enrich the world generation with villages and more POI, that\u0026rsquo;s something which can easily come later.\nIn the monthly update, I mentioned that the world needs some sort of fog system for unexplored tiles. I played around with a few different methods, but in the end it actually was easiest to just use Sprite3D set at an appropriate height, with some noise-based colouring and alpha for edges.","title":"Hexagon Update: 10 Nov 2022"},{"content":"After much deliberation, I ended up doing none of the things I thought as options when I wrote the last post .. and as it happens this ended up being a fairly simple implementation.\nStashed in the back of my code was a prefab I used for a lot of the early testing of biomes. Back then it looked like this:\nThe prefab itself is just a holder for a Sprite3D which was sized correctly to show as a border. It\u0026rsquo;s really just a PNG file with transparency. Anyway, I\u0026rsquo;d used it a fair bit, and even called it the \u0026ldquo;selector\u0026rdquo; prefab in the code. It had a script attached to do simple things like change the colour of the selector (by using the modulate property on the Sprite3D).\nBut I hadn\u0026rsquo;t actually used it for selection .. until now. Now it was definitely the shortest path to just showing what we could select as movement tiles. It was an already defined and built prefab, and because it was intended to be spawned only on tiles you could select, it made sense to just bake a collider into it as well.\nNow I had something I could spawn into the world which had both the visual indication to the player and the collider needed to make that space pickable. After that, it was a quick trip through the neighbours of the cell the player was on, and we\u0026rsquo;re off to the races.\nWhen we\u0026rsquo;re walking the neighbours for the current position, we need to test if we can move there. I had originally thought about baking a whole navigation mesh (probably actually just a filtered version of the one used to build roads?) but actually we can test the neighbours pretty fast against some simple policies.\nSo now every tile has player access policies called player_allowed:\n{ \u0026#34;type\u0026#34;: \u0026#34;grass\u0026#34;, \u0026#34;prefab_file\u0026#34;: \u0026#34;Tiles/hex_forest/hex_forest_detail.gltf.glb\u0026#34;, \u0026#34;cost\u0026#34;: 1.0, \u0026#34;road_cost\u0026#34;: 0.2, \u0026#34;allow_rotation\u0026#34;: true, \u0026#34;player_allowed\u0026#34;: \u0026#34;always\u0026#34; } The same was added to decorations:\n[ { \u0026#34;type\u0026#34;: \u0026#34;dock\u0026#34;, \u0026#34;prefab_file\u0026#34;: \u0026#34;TileDecorations/dock.glb\u0026#34;, \u0026#34;tile_types\u0026#34;: [ \u0026#34;water\u0026#34; ], \u0026#34;allow_rotation\u0026#34;: true, \u0026#34;allow_roads\u0026#34;: true, \u0026#34;show_roads\u0026#34;: true, \u0026#34;player_allowed\u0026#34;: \u0026#34;road_only\u0026#34; } ] There are three policies: never which blocks player movement either by decoration or by base tile, road_only which requires a road defined on the base tile (either enforced by decoration, or by the tile itself), and always which is treated as a fall-through for decorations and a hard policy for tiles.\n(Aside: Yes, always on a decoration really means well_maybe but anyway..)\nAfter walking the neighbours and testing if we can use them, it\u0026rsquo;s straight into spawning some prefabs and managing them coming in and out of existance as we move.\nThe work handling clicks had already been done in testing out if I needed to modify all tile prefabs.\nSo we have player movement! It respects tile polices, so players can cross water if a boat path (internally just a road with a pretty tile) but not walk out on to any water. Mountains block you walking through them.\nI made a quick video (with no audio because it\u0026rsquo;s mostly disabled in game at the moment), which appears below:\nThe player icon is definitely very placeholder. I\u0026rsquo;m not sure what I want to do for that.\nThe last part, and made after the video was uploaded, was to finally clean up the placenames display. For a long time I\u0026rsquo;ve used an on-map Label3D which provided world-space text, and sort of tried to make it flat on the map just below the castle.\nWell cities are a lot more than just a single castle tile now, and the flat label looks quite bad against the selection hexes, so it was time to move them out of the world map and into the UI.\nThere\u0026rsquo;s now a banner at the top of the screen which shows the current placename (just cities for now). It fades in/out as you move in or out of a city. It\u0026rsquo;s much cleaner I think than the old map label.\nI think they\u0026rsquo;re a huge improvement, but will also allow me to name general areas, such as lake/ocean pieces, counties, or biomes. The UI stuff is very very slowly starting to feel like it does what I want it to do with only some tearing of hair out. Previously I would lose a lot of hair and have no UI to show for it!\nOf the goals for the next month, all but one of the movement ones are now done which is nice for only a couple of days later! Don\u0026rsquo;t expect that much progress in the rest of the month however!\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-11-05/","summary":"After much deliberation, I ended up doing none of the things I thought as options when I wrote the last post .. and as it happens this ended up being a fairly simple implementation.\nStashed in the back of my code was a prefab I used for a lot of the early testing of biomes. Back then it looked like this:\nThe prefab itself is just a holder for a Sprite3D which was sized correctly to show as a border.","title":"Hexagon Update: 5 Nov 2022"},{"content":"This will be a quick update only..\nI\u0026rsquo;ve started working on allowing a placeholder player to be move around the world. Actually, this wasn\u0026rsquo;t too hard, it even does a nice tween that deals with distance. I don\u0026rsquo;t actually need to do that (I expect players to move hex by hex) but it\u0026rsquo;s nice to know the code works.\nBy \u0026ldquo;wasn\u0026rsquo;t too hard\u0026rdquo;, it did open up the can of worms I\u0026rsquo;ve been waiting to have pounce on me.\nThe first thing was the default node for just holding UI elements will block all mouse interaction below it in the scene. This is not the first time I\u0026rsquo;ve scratched my head for a good long while wondering why no mouse events seem to reach the view of the world. I am not sure why essentially a holder for UI nodes defaults to blocking mouse events. It can be disabled, but by default if you just create this simple bag of holding UI, it blocks mouse events.\nAnyway, once that was out of the way (literally) mouse events were cleanly getting down through to the world map and useful events coming from it. The easy way to get an event for clicking or tapping an object is to make it \u0026ldquo;pickable\u0026rdquo;, which means throwing a collider on it and then ensuring \u0026ldquo;pickable\u0026rdquo; is ticked. Easy! In fact Godot then takes care of a ton of problems for you, just connect the signal out of any tile to a common handler, and it takes care of all the conversion from viewport-camera coordinates to \u0026ldquo;real\u0026rdquo; world ones and you\u0026rsquo;re off.\nOkay, so there\u0026rsquo;s the can of worms. Every tile would need a collider to do it this way. Or, maybe only the active selectable ones. Maybe the collider is built at runtime, or on importing models, .. or it\u0026rsquo;s baked into a nice prefab that could hold a bunch of other things. The options are a bit far and wide. That\u0026rsquo;s before you go down the path of just raycasting yourself out the camera on a low-level mouse click.\nI\u0026rsquo;m loathe to rebuild all the tiles again shifting from the ready-to-go GLTF that Godot handles fairly well. I\u0026rsquo;ve already walked every single one externalising materials so I can apply my own common set to tiles. And I would have to do something else to use more raw mesh formats and override the materials.\nBuilding the collider on import is what I\u0026rsquo;ve done in other projects before. It\u0026rsquo;s not too hard to programatically create one as tile is being loaded. But it feels like ugly code and another loading step, is marginally harder to position correctly, but mostly feels \u0026ldquo;anti-Godot\u0026rdquo; somehow? It has a scene system, so why add complexity fiddling with models in code.\nThere\u0026rsquo;s also the point that, as I said above, if I\u0026rsquo;m moving hex by hex I could actually just add colliders at runtime when we want to move, and add them only to the valid tiles. But that\u0026rsquo;s also got problems, the relationship between the collider at the hex is either disconnected (and we need to calculate the placement in the world separately), or it\u0026rsquo;s a child of the tile, but then we\u0026rsquo;re tinkering with the tile\u0026rsquo;s children (which means we have to be careful to clean up).\nAnd sitting in the back of my head is that if I were to rebuild the tiles I could also add some other features to them. If I wanted to have smoke from a chimney, or moving water wheels, then this is all easier to do with taking the meshes more directly into a prefab and include all the other elements (like animation nodes) in there.\nIn other words, rebuilding them is probably going to happen eventually and if I do half that job now, then adding animations and particles to them is \u0026ldquo;fairly\u0026rdquo; easy.\nIn the meantime, the game has a proper pause menu and saving just needs to be wired to the save button. So it\u0026rsquo;s not a lot of progress, but there has been some!\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-11-03/","summary":"This will be a quick update only..\nI\u0026rsquo;ve started working on allowing a placeholder player to be move around the world. Actually, this wasn\u0026rsquo;t too hard, it even does a nice tween that deals with distance. I don\u0026rsquo;t actually need to do that (I expect players to move hex by hex) but it\u0026rsquo;s nice to know the code works.\nBy \u0026ldquo;wasn\u0026rsquo;t too hard\u0026rdquo;, it did open up the can of worms I\u0026rsquo;ve been waiting to have pounce on me.","title":"Hexagon Update: 3 Nov 2022"},{"content":"Around a month ago, I started writing this silly game and I must admit I am still surprised it\u0026rsquo;s gotten to the point it has. I expected that world generation would really be my undoing, and instead it seems to be going okay.\nThen vs Now 28 September 2022 31 October 2022 Current State So where are we at now? Well, here\u0026rsquo;s a short list of what was done in the last month:\nInterim camera movement (currently using WASD) Hexagon tile placement, along with most of the math to manage simple tile relationships (like neighbours) Tile attributes are not hard-coded, but defined in JSON and interpreted by the code building the current view Tiles are spawned/removed automatically by camera view Tiles can have a decoration placed on top, and rules enforced by attributes in JSON Tile decorations can react to roads and push to a different decoration Tile models can be normalised for connections to other tiles, generate the rotation of tiles needed to make all possible combinations World Generation: Repeatable generation from a seed Biomes (defined but not yet used) Terrain (including height) Forests Cities with walls, generated names, and internal details Transport built between cities that respect terrain (roads for land, boat paths for water, and transition details between land/water), terrain has costs for being traversed depending on tile and height, avoidance of tiles or tile decorations for transport paths Saving and loading game state including map Managing save game slots Global setting saving and loading (eg, music volume) Yeah I really am surprised all that got done, and works.\nUnrealistic Future Plans The next month or so I want to focus on two things:\nFinish world generation Build \u0026ldquo;counties\u0026rdquo; for difficulty level Add more POIs than just cities (like, villages, mines, farms, lumber yards, mills, and watch towers) Add a little more detailing to grass than just bulk forest Movement Visual representation of where the player is Show navigation rule application Allow player to move around the map \u0026ldquo;Fog of War\u0026rdquo;-like discovery of the map Let\u0026rsquo;s see how this all goes!\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-10-31/","summary":"Around a month ago, I started writing this silly game and I must admit I am still surprised it\u0026rsquo;s gotten to the point it has. I expected that world generation would really be my undoing, and instead it seems to be going okay.\nThen vs Now 28 September 2022 31 October 2022 Current State So where are we at now? Well, here\u0026rsquo;s a short list of what was done in the last month:","title":"Hexagon Update: One Month"},{"content":"Lots since the last update, lets dive into it.\nRefactoring Outcome Refactoring all the road generation to use tile variants instead of laying a separate prefab on top was a Huge Success and was definitely the right approach.\nBaking the roads into the tile set took a while but it resulted in a much nicer implementation internally, as I took the chance to also drop object pooling.\nAn optimization I had done very early on was to push 3D tiles into a pool of pre-instantiated objects and pull them into the world as needed. This is fairly useful in most game engines, but actually in Godot it turns out it has no useful performance gain at all.\nIn Godot, the cost of .instantiate() is basically nothing and you get a much cleaner code path without involving your own object pool. You can just create objects and then .queue_free() them when done. The name of that function hints at what is going on under the hood, and something I hadn\u0026rsquo;t really noticed until I did the refactor.\nSo long as you\u0026rsquo;ve already loaded the resource, the cost of spawning many new ones at once is as low as all the work needed to maintain the object pool. Having an object pool adds huge complexity (mostly on the freeing side, you can\u0026rsquo;t just free the object, you need to \u0026ldquo;hand back\u0026rdquo; the object to the pool). Given all the extra complexity with no performance gain, it was a good thing to remove it entirely and write more simple code.\nStalling Having refactored all code around the map view and in turn the way we load tile type information, it was time to revisit world generation, but specifically about both how slow it ran and the lack of feedback.\nProviding feedback to the user is really important. If you\u0026rsquo;re given a blank screen with no visible activity, the instinct is the game has crashed or is otherwise misbehaving, and to kill it. It\u0026rsquo;s important while doing heavy work to show work being done, and ideally some indication about the progress of that work.\nOkay, no worries, Godot has progress bars and text I can display for such things. But despite sending updates to the progress bars and text, nothing rendered until it was all done.\nThe immediate approach I took was to slice off the world generation into a thread and then just wait around for that to complete. This sort of worked and then I changed things and it didn\u0026rsquo;t, and because I\u0026rsquo;m not the smartest person I couldn\u0026rsquo;t remember what was actually changed which made any difference.\nGodot supports threads, and all the supporting elements needed to make threads word (like mutexes and semaphores). Alas, adding all these in various places didn\u0026rsquo;t make the code behave any better. In one part of the code, we\u0026rsquo;d test if the thread was running and it would always return false, while the output showed the thread clearly still running and spamming the log with messages.\nIt also didn\u0026rsquo;t help that it started to look like sometimes if you called functions they actually somehow caused all the visual rendering to stall even if that function should have been in a thread.. right?\nTwo days later, I now have a better understanding of both Godot\u0026rsquo;s main loop and most of the downsides of threads. Not a fun two days.\nOne thing I had forgotten is by and large games are single-threaded. They might offload certain low level functions to a thread, like audio playing or physics, but many games (and game engines) are single threaded because there are less complications about data access and synchronization than a multi-threaded game or engine.\nIn Godot\u0026rsquo;s case, rendering and _ready() in a script share a thread, so if you block in _ready() then rendering ain\u0026rsquo;t going to work. But, I had \u0026ldquo;solved\u0026rdquo; this with making sure world gen was on a thread.\nWell, sort of. Yes, some of it was on a thread, but not all of it, and it was hard to identify what was actually executing where. A lot of print-as-debug was added with every line including the output of OS.get_thread_caller_id to show where this was really taking place.\nWhat I found was it looks like singletons in Godot always execute on the main thread, and the way to avoid this is ensure any functions you call are on separate objects in your thread. Okay, refactor around that a bit (the calls into the world map singleton are fast, so we\u0026rsquo;ll ignore they run in the main thread, but it meant world gen had to be separated from the singleton).\nStill, we had problems, threads were being reported to the main code as finished when the logs were full of signs they were running. Getting to the bottom of this I think came down to pure luck and writing a separate set of tests in a different Godot project.\nThe test case I wrote looked something like the following. Note in this example we have a script on a node called SimpleProgressBar which updates different elements, like upper and lower text messages as well as the bar itself.\nvar progress_bar : Node var m : Mutex func _ready(): # we\u0026#39;ll use a progress bar for visuals progress_bar = get_node(\u0026#34;SimpleProgressBar\u0026#34;) # we\u0026#39;ll use this to protect our access m = Mutex.new() # start the long work thread var t = Thread.new() t.start(Callable(self,\u0026#34;_long_work_thread\u0026#34;)) for i in range(0,100): # update the progress bar too! m.lock() progress_bar.set_progress(i) m.unlock() await get_tree().create_timer(1).timeout # wait for the thread to exist while t.is_alive(): await get_tree().create_timer(1).timeout # clean up thread (normally blocks unless thread is dead) t.wait_until_finished() func _long_work_thread(): for i in range(0,100): # update the progress bar, ensuring no-one else is m.lock() progress_bar.set_lower_text(\u0026#34;Long process step %d\u0026#34; % i) m.unlock() # simulate a long process OS.delay_msec(5000) Okay, so the test case worked, even though I was sure I was doing the same thing in my game code. The long work thread continues to update the progress bar and this visually updates, and the code in _ready() waits for the long work thread to complete. It turns out, I wasn\u0026rsquo;t doing this actually, and the detail is interesting.\nThe use of await in _ready() is because we don\u0026rsquo;t want to block, we know that we can\u0026rsquo;t call OS.delay_msec() because it would block and then rendering would stop. In the thread, we can just block (after all, that\u0026rsquo;s the point of the thread), so we call OS.delay_msec().\nGoing back over my game code, surely it doesn\u0026rsquo;t matter in a thread if we block or not, the thread is separate and we can do what we like. Oh, no, we definitely can\u0026rsquo;t.\nLet\u0026rsquo;s use a non-blocking delay instead in the long work thread, change OS.delay_msec(5000) to await get_tree().create_timer(5).timeout which is the same 5 second delay. Suddenly now the main code in _ready doesn\u0026rsquo;t wait for the thread to finish, it just plows through having been told from the result of t.is_alive() that the thread is dead.\nIt appears that you cannot call await in a thread other than the main thread. For whatever reason, the thread is lost and forgotten and you can\u0026rsquo;t get back to it. It is not the case that creating a thread gives you the same properties as the main thread at all.\nThe reason this tripped me up is that I was also doing some fancy fades using tweens to the progress bar. The common way to write this (and comes up in all the searches BTW) is:\nvar tween = create_tween() tween.tween_property(progress_bar, \u0026#34;modulate:a\u0026#34;, 1.0, 1.0) await t.finished So naturally, in my thread for doing long work, it started with that exact fragment. And then the thread blew up.\nIn fact, in the main loop we can do that, but we must block if we want to do that in a thread, and it becomes:\nvar tween = create_tween() tween.tween_property(progress_bar, \u0026#34;modulate:a\u0026#34;, 1.0, 1.0) while tween.is_running(): OS.delay_msec(100) Annoyingly, this also still causes rendering issues, but mostly it seems to be because OS.delay_msec() might just busy-loop and so it starves something else of cycles, so you get stuttering and uneven tweens.\nThe alternative to a thread for long work is our friend await and littering your long work with lots of calls to await get_tree().process_frame which will gracefully leave to allow rendering to continue for a whole frame, and then come back. This is pretty much how a single-threaded game should be doing things, but it certainly feels rough to write.\nAnyway, that\u0026rsquo;s two days I won\u0026rsquo;t get back.\nI\u0026rsquo;m unsure if I\u0026rsquo;ll revert out of threads for things like world gen, or leave it there. Now it has no problems with unexplained \u0026ldquo;death\u0026rdquo; it works so I\u0026rsquo;m tempted not to touch that whole space for a while.\nPerformance was also problematic for generating the world (even in a nice thread). There were quite a few cases where I was using a Dictionary for performance and then throwing that all away by forcing GDscript to iterate over an Array, which is a lot slower.\nFor example, here\u0026rsquo;s a few of ways of testing if we have something:\nvar big_thing : Dictionary() # ... if big_thing.has(\u0026#34;key\u0026#34;): # ... if \u0026#34;key\u0026#34; in big_thing: # ... if \u0026#34;key\u0026#34; in big_thing.keys() # ... The first is obviously using the dictionary correctly. The second and third I thought were the same, because of the in operator. This is not the case: using in with a Dictionary is functionally the same as calling .has() on it, while using in with the result of .keys() of the Dictionary produces an Array and then uses the in operator on it which is really really slow.\nI\u0026rsquo;ve been mixing all three types without much care, and it actually matters a lot. I still randomly pick between x.has(key) and key in x which isn\u0026rsquo;t so good, but for now at least they both don\u0026rsquo;t suck.\nThis alone was responsible for a large amount of lost time in world generation.\nSaving and Loading After the fun with threads, I got on with actually useful progress (ha ha) and implemented saving and loading the game state. This is mostly easy, and apart from not clearing out some state when loading, it just works.\nSave games are packed binary files, because serialization to say JSON is kind of annoying. Lots of types you have to munge and can\u0026rsquo;t just call JSON.stringify() on a wodge of data. Instead you have to pick out and transform some things to strings before trying to throw them into JSON.\nIt\u0026rsquo;s not that stringify() can\u0026rsquo;t convert some types to strings, it does that just fine. It\u0026rsquo;s that the inverse function, parse() doesn\u0026rsquo;t understand how to reverse stringify() for all cases.\nTake a Vector2, the string version is something like \u0026quot;(1.0, 2.0)\u0026quot;, which is just fine, it\u0026rsquo;s what JSON.stringify() produces, it\u0026rsquo;s valid JSON so all good. However, parse() just sees that as a string and gives you back .. a string. Fair enough, it is a string, but it\u0026rsquo;s a string you \u0026ndash; Mr JSON class \u0026ndash; put there. You want to give me back what I put into you? \u0026ldquo;Hell no\u0026rdquo; says Mr JSON class.\nThankfully, compared to the threading stuff, that\u0026rsquo;s easy to deal with. Don\u0026rsquo;t use JSON for save games.\n(Aside: Not that binary is free of any quirks either. The binary store/load functions have .store_string() which most definitely does not \u0026ldquo;store\u0026rdquo; a string like every other function with \u0026ldquo;store\u0026rdquo; in the name. There is no .get_string() to match it, while every other \u0026ldquo;store\u0026rdquo; function has a matching \u0026ldquo;get\u0026rdquo;. It wasn\u0026rsquo;t immediately obvious if you want to store/load a string you really need to use .store_pascal_string() which has a matching \u0026ldquo;get\u0026rdquo; and is a great throwback to a long forgotten language.)\nNext up Because I can\u0026rsquo;t leave well enough alone, I\u0026rsquo;m exploring a different tile set to the one currently being used. It has some nice features, like hexagons are more obviously visible, and a lot of interesting decorations for tiles.\nWhile playing around with a different tile set, it\u0026rsquo;s also become clear I am not handling materials on tiles in a way that makes it a bit easier for me to tweak the tile colouring and surface. So we\u0026rsquo;ll also be fixing that for the tile sets as well.\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-10-25/","summary":"Lots since the last update, lets dive into it.\nRefactoring Outcome Refactoring all the road generation to use tile variants instead of laying a separate prefab on top was a Huge Success and was definitely the right approach.\nBaking the roads into the tile set took a while but it resulted in a much nicer implementation internally, as I took the chance to also drop object pooling.\nAn optimization I had done very early on was to push 3D tiles into a pool of pre-instantiated objects and pull them into the world as needed.","title":"Hexagon Update: 25 Oct 2022"},{"content":" So I am now deep in the refactor well, and I\u0026rsquo;m pretty sure I can eventually get myself out, but right now everything is broken until I get to the bottom of the well, and start digging my way up.\nWhat triggered this was supporting roads. In the picture I posted on the last update there was a lovely road going through the gap in the forest. But there wasn\u0026rsquo;t a gap there really.\nThe road pieces can be spawned on top of any tile, and that\u0026rsquo;s how it looks like it could be used, but then you can\u0026rsquo;t really use them on any tile which has other things on it. That is, it works on the plain flat tiles, but not say a forest tile. On a forest tile, you get a look of a road which has trees all over it.\nTo work around that did a quick hack to just force the tile to one of the plain flat ones when a road gets created on a tile that isn\u0026rsquo;t so well designed for roads. Thus, the picture of the road going through the gap in forest is really the road mowing down all the forest tiles in its way on the shortest bit of forest to cross.\nI didn\u0026rsquo;t really like that, a road piece that neatly weaved through a forest closely would be nicer. And nicer becomes \u0026ldquo;let\u0026rsquo;s refactor the entire world\u0026rdquo;.\nThe upside is the tiles will look better when done, and at the same time I have half an idea of how to manage water traversal as well. It\u0026rsquo;ll involve less objects in the world as well.\nI have progressively integrated the road pieces, in some cases recolouring them, into the base tiles and adjusted the decorations on those tiles to allow the road piece to fit in, and then collected it all into a new tile - original base tile plus road piece - so they can be spawned at once.\nThis is mostly some work in Blender, since the tiles are all easily messed with in Blender. Using Blender falls into that slightly annoying tool space where KiCAD lives in my head as well. It\u0026rsquo;s one of those tools where knowing the keyboard actions really matters and without that you will struggle to do anything quickly at all.\nAnyway, that bit is done, I have many more tiles than I had before, and the ugly code and metadata reorganisation has begun.\nI\u0026rsquo;ll surface in a few days to report why I shouldn\u0026rsquo;t have done this.\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-10-21/","summary":"So I am now deep in the refactor well, and I\u0026rsquo;m pretty sure I can eventually get myself out, but right now everything is broken until I get to the bottom of the well, and start digging my way up.\nWhat triggered this was supporting roads. In the picture I posted on the last update there was a lovely road going through the gap in the forest. But there wasn\u0026rsquo;t a gap there really.","title":"Hexagon Update: Oh no"},{"content":"Well, it wouldn\u0026rsquo;t be my code development if any design pattern lasted longer than four hours! In fact, in the previous post it omits the details this was actually the second pass, where we stored masks in the tile data directly, rather than in a different set of dictionaries.\nBut, before tackling changing everything again, I did get to a better place about how to draw roads on the map. Not the display part now, the actual \u0026ldquo;draw road from A to B\u0026rdquo; including all the steps needed to join them.\nPathfinding is a well trodden area in game design. There\u0026rsquo;s a bunch of methods, but the A* algorithm fits my needs pretty well. This involves building a graph of nodes connected by edges, and assigning weights or costs or whatever you want to call it to traversing the node or edge.\nI was thinking I might have to build A* myself in GDscript but what\u0026rsquo;s this? Oh, Godot already includes A* classes to do all the work for me. Well, most of the work anyway, the traversal bit anyway. In Godot 4 we actually get three different versions of A*, mostly separated by the node elements.\nBecause we\u0026rsquo;re doing pathfinding on a 2D plane1 we\u0026rsquo;ll use the AStar2D class for our pathfinding. This provides two virtual methods we will need to replace, _compute_cost() and _estimate_cost() which given two points returns the exact or lower-bound cost of the path between the two points.\nWe have to overide those as we want our costs based on axial coordinate distances, not cartesian coordinates for the tiles themselves. And the AStar2D wants nodes with cartesian coordinates (specifically, it expects Vector2 coordinates). I should point out, this is noted in the Red Blog Games Hexagon Guide about Pathfinding, and is not something I\u0026rsquo;ve pulled out of skill or knowledge myself!\nAs we have a grid of tiles (albeit a hexagon grid), we\u0026rsquo;ll just throw a graph containing a node for every tile, and connections from each node to all neighbours that meet appropriate criteria (mostly, can put a road on it!)\nAt this point, the current implementation and the one I want to move to changes a bit. I\u0026rsquo;ve added costs to the metadata about tile types, as we\u0026rsquo;re applying something simple as a policy: tiles like grass are easy to move on, tiles like forests and mountains are harder but not impossible, and water should be impossible .. for now.\nI am making forests and mountains hard but not impossible to produce roads that tend to avoid these obstacles rather than plow through them, but will plow through them when there\u0026rsquo;s little choice but to make a very large detour around them. I think this will produce a pleasing balance between direct straight line roads and roads which have nice natural curves and meandering.\nAs it happens, building the graph the AStar2D class needs is remarkably easy. When we create a new tile (using the badly named set_tile()) we generate the point index the graph wants and store it with the tile. Then in update_tile() (which gets called either directly or by set_tile()) we add/update the point in the graph with the cost of that type of tile. This means when we change tiles we also update the costs in the graph of the tile.\nHowever, we also need to maintain the graph, so we do this in update_tile() as well. We also need to remove the point if the tile is no longer navigable, and connect or disconnect points in the graph as well. For connecting and disconnecting points, we walk our neighbours and check if they are appropriate to move into, and then add these appropriate connections.\nIn psuedo-code, for each tile we update it looks like:\nif updating tile: if tile_type is allowed road: add/update this point in graph for each neighbour: if neighbour is allowed road: add connection between this tile and neighbour tile else: remove connection between this tile and neighbour tile else: for each neighbour: remove connection between this tile and neighbour tile remove point from graph Once we have the graph with nodes, we can ask it for the path between two points. Because the AStar2D class expects point indexes, there\u0026rsquo;s a bunch of translation back and forth between axial coordinates of tiles and the point index. But, that\u0026rsquo;s fairly quick and thus we have roads which look more natural:\nI said there were things I wanted to change, and in writing this down plus the development issues, I think it will be reworked a bit very shortly.\nThe first problem is that as road pieces are expected to sit on a tile, they clash with some tiles. Forests, for example, don\u0026rsquo;t really look so good with a road going through them because the trees on the tile look like they\u0026rsquo;re on the road. To work around that, the current version just forces the tile to grass if it was forest before.\nThe other problem is water. Water is currently not allowed for traversal. It makes no sense, it\u0026rsquo;s a road, not a boat. How this is going to be managed is uncertain, but it\u0026rsquo;ll have to be some how. The map may end up with a slice of water dividing it in two and without any way of generating a road between the two sides.\nBut these are problems for another day.\nThe world is a flat plane even if we were to jazz it up a bit with tiles at different heights. That is, the player can\u0026rsquo;t decide to go up or down within a tile, they can only go to whatever height the tile is. So all our positions are 2D, thus navigation is on a 2D plane.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-10-18/","summary":"Well, it wouldn\u0026rsquo;t be my code development if any design pattern lasted longer than four hours! In fact, in the previous post it omits the details this was actually the second pass, where we stored masks in the tile data directly, rather than in a different set of dictionaries.\nBut, before tackling changing everything again, I did get to a better place about how to draw roads on the map. Not the display part now, the actual \u0026ldquo;draw road from A to B\u0026rdquo; including all the steps needed to join them.","title":"Hexagon Update: Roads .. again"},{"content":"As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.\nThe first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can\u0026rsquo;t see them. Also, I expect I\u0026rsquo;ll need to do extensive debugging on road generation and so I\u0026rsquo;ll also need to see them.\nThe tileset I\u0026rsquo;m using1 has roads as separate models to be added to the base tiles. The models cover all possible exit positions and combinations, although they have been normalised so some combinations and positions require rotating the model.\nYou can see the road tiles towards the bottom left corner of the image above (taken from Kenney.nl\u0026rsquo;s website).\nFor all of the tiles I\u0026rsquo;m using, I load these into the game based on some metadata about the tile, using a simple JSON file containing a list of the tiles and their metadata. For example, on the main tile set I have a metadata index containing:\n{ \u0026#34;water\u0026#34;: { \u0026#34;prefab_file\u0026#34;: \u0026#34;Tiles/water.glb\u0026#34;, \u0026#34;tags\u0026#34;: [ \u0026#34;water\u0026#34; ] }, \u0026#34;grass\u0026#34;: { \u0026#34;prefab_file\u0026#34;: \u0026#34;Tiles/grass.glb\u0026#34;, \u0026#34;tags\u0026#34;: [ \u0026#34;grass\u0026#34; ] } } (Aside: we actually read the metadata first and call load() on the prefab_file specified here, which gives us scenes to instance into the world. Everything is loaded into a Dictionary for easy access.)\nThe same approach is taken with road tiles, where we annotate what exits a given road piece has:\n[ { \u0026#34;exits\u0026#34;: [ \u0026#34;right\u0026#34;, \u0026#34;left\u0026#34; ], \u0026#34;prefab_file\u0026#34;: \u0026#34;Roads/path_straight.glb\u0026#34; }, { \u0026#34;exits\u0026#34;: [ \u0026#34;right\u0026#34; ], \u0026#34;prefab_file\u0026#34;: \u0026#34;Roads/path_start.glb\u0026#34; } ] As mentioned above, each road piece needs to be rotated to produce all of the possible combinations. The path_straight.glb piece has two other rotations available, 60 degrees should give us exits of [ \u0026quot;up_right\u0026quot;, \u0026quot;down_left\u0026quot; ], and 120 should give us [ \u0026quot;down_right\u0026quot;, \u0026quot;up_left\u0026quot; ]. (Probably, I haven\u0026rsquo;t checked this is correct!)\nIn the first pass of this code, I just wrote out the combinations by hand, adding a \u0026quot;rotation\u0026quot; field to the metadata. But I quickly found this was cumbersome, more so when I got the exits for a given rotation wrong (usually 0 degrees, so everything from there was wrong!). Instead, we produce all of the other possible exit positions for a road piece by iterating over the six different possible rotations and rotating the exits at the same time.\nAt this point, it\u0026rsquo;s useful to talk about how I resolve a tile having a specific list of exits to a road piece. We need to ignore the order the exits were provided in, and we need a fast way to look it up.\nThe naive implementation would be to stick all the exit combinations into an array that points to the tile/rotation needed. Then we walk over every element in the array of combinations, and then on each combination (itself an array) we compare it to the array of exits we have.\nThis is slow, we\u0026rsquo;re walking all possible combinations, and then also doing a bunch of array walks and then string compares to compare the exit arrays. Now, maybe this is premature, but there are faster ways to do this.\nInstead of storing the possible exits as an array of strings, we convert them to a bitfield. This has a few advantages:\nIt reduces the exits to a fixed order, regardless of how they appear in the metadata Bitfields are trivial to compare, they end up just as an int Using an int as a Dictionary key is fast and reliable Rotating the exits is very easy in a bitfield Now some of my younger readers will be wondering why on earth I would go deep into integer math to do this. Well, my programming roots include a great deal of C (that\u0026rsquo;s C, not C++, not C#) on microcontrollers, and that space is all about bitfields. And one thing you learn quickly in that space is when you have very few cycles, bitfields are very efficient at solving a bunch of problems.\nDuring import of the road pieces, we convert the exits array for a piece into a bitfield. We do this by assigning a bit to each exit, and the order of the bits corospond to going around the possible rotations. In sort of psuedocode, we do this:\nstr_to_mask = { \u0026#34;right\u0026#34;: 0x1, \u0026#34;up_right\u0026#34;: 0x2, \u0026#34;up_left\u0026#34;: 0x4, \u0026#34;left\u0026#34;: 0x8, \u0026#34;down_left\u0026#34;: 0x10, \u0026#34;down_right\u0026#34;: 0x20 } function exits_to_mask(exit_array) -\u0026gt; int mask = 0 for exit in exit_array: mask = mask | dirs_to_mask[exit] return mask The magic numbers are just the hexadecimal value of each bit being set (and only that bit).\nWhen stashing the road tile, we then use the mask for the key in the Dictionary, which will be a trivial lookup. (Aside: nearly $O(1)$ if you really want to know.)\nI said above that rotation is easy as well. If we\u0026rsquo;ve got an array of strings, we can\u0026rsquo;t just move the array contents around, we have to map each exit to the exit rotated one step around. The map is not slow itself (we can just have another lookup table), but in addition to all the string comparisons in the lookup table we need to walk all the exit array members.\nInstead, with the bitfield approach, we can rely on bit-shift operations to do the rotation, with a small bit of work to manage roll-over. Bit-shifting is often implemented in pure hardware, so it is reasonably efficient. Rotating the exit list each item is then just:\nfunction rotate_exits(mask) -\u0026gt; int # shift all the exits along mask = mask \u0026lt;\u0026lt; 1 # pass the rollover bit to the bottom mask = mask | (mask \u0026amp; 0x40 \u0026gt;\u0026gt; 5) # only keep the bits we\u0026#39;re interested in mask = mask \u0026amp; 0x3f # and return it return mask (Aside: most calculator apps will have a programmer mode that includes bit-shift and logical operations, which will show why this works.)\nGiven this, it\u0026rsquo;s fast to generate all the other road exit combinations for a given road piece, and to look up what piece we need for any combination.\nFor storage of road information, we mark tiles as having a road, and store the bitfield of exits. Adding a new road exit is purely doing a bit-wise OR on that exit in the tile. We also need to adjust the neighbour tile to reflect the connection back, but this is also a bit-wise OR.\nThis reduces our display effort to something very easy, just pull the road bitfield, look up that value in the index of all road pieces that are index by bitfield, and spawn the object in the correct place and rotation.\nEasy!\nKenney.nl Hexagon Kit\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-10-17/","summary":"As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.\nThe first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can\u0026rsquo;t see them. Also, I expect I\u0026rsquo;ll need to do extensive debugging on road generation and so I\u0026rsquo;ll also need to see them.","title":"Hexagon Update: Roads"},{"content":"I realised that since I started writing this silly wee game I actually haven\u0026rsquo;t written down any of the initial thoughts about how this was goign to work, and since I\u0026rsquo;ve only just resurrected writing a blog after I\u0026rsquo;d already started writing the game there\u0026rsquo;s no history here either.\nRight, let\u0026rsquo;s see about writing some of those thoughts down.\nHexagon tiles I\u0026rsquo;m implementing a classical RPG and hexagon tiles are pretty common for maps in that context. Square maps are also an option, but I feel like they lend themselves better to worlds where you and the party are in fine-definition worlds, where hexagons are better at coarse-definition worlds.\nSo for example, in a fine-definition world a city or a village is a large number of tiles, you have the city\u0026rsquo;s streets to actually navigate around etc. In a coarse-definition world the city is one tile, possibly with some visual sugar around that, but internal city views are a bit more menu-like and less navigated using tiles.\nThis does also make some types of generation of the world a bit easier, because we really only looking at high-level detail and that has a lot fewer elements to try to model. Cities are just a single world position and not a complex map of tiles within the world.\nThat said, there\u0026rsquo;s nothing stopping me from implementing a nested world approach - where entering a city essentially creates a new hexagon map at a finer level of detail - so we\u0026rsquo;re not really closing ourselves off on doing that level of detail. It would always be a scene switch to do it, however.\nSince I\u0026rsquo;m pretty rubbish at art, I\u0026rsquo;m leaning into Kenney\u0026amp;rsquo;s Assets which include a Hexagon Tile Kit. So we have enough art to do world generation and some idea what the tile set should be able to do, if I can write the supporting code. If you have an interest in game dev but not much ability in art, then you really should look at Kenney\u0026rsquo;s work as it\u0026rsquo;s high quality and available under very generous license terms.\nThe tile set is flexible enough to be coarse or fine-definition, for the most part. There\u0026rsquo;s some gaps here and there but for this game in this state the gaps are just small workarounds.\nHexagon math Having a set of actual 3D tiles is all very well but you have to position them. The positioning is some very well documented math, the resource I used is Red Blob Games Hexagonal Grids which is extremely clearly written and easily implemented in any language you like. I\u0026rsquo;m not going to explain any of the math here!\nThe discussion on co-ordinate systems in Red Blob Games\u0026rsquo;s guide is very important to read before going to far into the development. I settled on the Axial coordinate system described in the guide.\nI didn\u0026rsquo;t consider the offset coordinate systems desscribed there for long because the math is annoying for neighbours, directions, distances etc. They were easiest to deal with by converting offset to cube or axial coordinates and if that\u0026rsquo;s the case I might as well use cube or axial natively.\nComparing axial to cube, the big advantage of axial is that the coordinates are always valid, as they are in offset systems. That is, a random value for each coordinate dimension is always okay, but with cube coordinates valid coordinates are only where they sum to zero.\nSince the vector math for axial is nothing unusual, we can use Godot\u0026rsquo;s Vector2i type for an axial coordinate. I\u0026rsquo;m using Vector3i for cube coordinates and there\u0026rsquo;s conversion functions between them documented in the Red Blob Games guide.\nThe conversion from axial to world (ie, where we place a hex on a flat plane) is also in the guide and is easy to implement. That makes positioning in the game\u0026rsquo;s 3D world coordinate space quick to do.\nCamera Hexagon tile games are commonly seen with both perspective cameras and orthographic cameras. The difference between the two is something you are best just firing at a search engine, but the tldr is perspective is what we see normally (far away objects are smaller), and ortographic keeps everything the same size regardless of distance.\nThe latter camera has the same look as games that use a 2D engine with tiles that fake 3Dness, the classic \u0026ldquo;isometric\u0026rdquo; look. That particular look is historically very common for an RPG or tile base game.\nAlthough it\u0026rsquo;s tempting to ram home the somewhat retro ideas in the game by using an isometric (or approximately isometric) view, I\u0026rsquo;ve ended up using a perspective camera as I have had endless problems with Godot\u0026rsquo;s orthographic camera, ranging from clipping models to annoying lighting behaviour.\nI know that there\u0026rsquo;s a big chunk of this which is just my understanding of how to correctly configure and drive the camera, but perspective \u0026ldquo;Just Works\u0026rdquo; and it\u0026rsquo;s perfectly valid for a tile RPG (or other hexagonal grid games, like Civilization), so I\u0026rsquo;m taking the path of least resistance.\nHexagon storage The Red Blob Games guide to Hexagon grids discusses some issues around storage, but this is actually a pretty easy decision.\nSince Godot provides Dictionary type, and we can use axial coordinates (really Vector2i) as keys, it is the fastest and easiest way to store the map data. It will tolerate any shape and holes or partially generated state. It has fast access since it uses a hash to return the content of a specific key, it enforces unique keys, and walking the whole map is no harder than any other storage approach. It stores about as efficiently as is possible.\nAs I\u0026rsquo;m using axial coordinates, there are helper functions to do things like return the neighours of a coordinate, or the tile in a specific direction and distance, and so forth. We don\u0026rsquo;t rely on the data storage structure to provide those constructs, so it doesn\u0026rsquo;t matter that the storage has no concept of these.\nHowever, there\u0026rsquo;s one issue with storage of a world..\nInfinite vs Finite I am a fan of infinite prodcedural worlds. But for this game, I don\u0026rsquo;t think we need a world we move infinitely in any direction, as we can provide new generated challenges within a finite world.\nNot allowing the world to be infinite has several benefits. For one, world generation is simplier if the world is finite, as we can simply iterate over the world multiple times to add features to it. With infinite worlds, each area or chunk (generally) needs to be generated independently and unexpectedly.\nThe other comes with approaching difficulty for the player. Rather than having the difficulty determined by some value proportionate to experience or gear, I would like difficulty to be determined by the location the player is at.\nThat is, difficulty is a function of the distance from a \u0026ldquo;safe\u0026rdquo; point to the edge of the world. For easy implementation, we\u0026rsquo;ll set the safe point to the literal center of the world (Vector2i(0,0)). This means when the player travels far away from the center the challenges are more difficult, but they can easily control what challenges they want to manage just by moving around.\nWith an infinite world, you can do this, but I feel like it takes away from one of the values of an infinite world (that is, you can just \u0026ldquo;explore\u0026rdquo; and you aren\u0026rsquo;t bound to the same place, but you can\u0026rsquo;t if the difficulty gets worse the further you are out).\nAt the same time, I can hand-wave away the storage of the world needing chunks because we don\u0026rsquo;t need chunks straight away for a finite world. Let\u0026rsquo;s just make the whole world sit in RAM. What could go wrong?\nWraping up Thus, the game being written is:\nA finite world, so we can cut corners on world gen Difficulty scales by distance from the centre, in which case we can just use a \u0026ldquo;circular\u0026rdquo; (actually big hexagon) shape for the world Perspective because Orthogonal camera disagrees with me Doesn\u0026rsquo;t yet try to do anything to load/save/cache chunks but just has everything in memory at once There\u0026rsquo;s other decisions yet to come, but this\u0026rsquo;ll do for now.\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-10-13/","summary":"I realised that since I started writing this silly wee game I actually haven\u0026rsquo;t written down any of the initial thoughts about how this was goign to work, and since I\u0026rsquo;ve only just resurrected writing a blog after I\u0026rsquo;d already started writing the game there\u0026rsquo;s no history here either.\nRight, let\u0026rsquo;s see about writing some of those thoughts down.\nHexagon tiles I\u0026rsquo;m implementing a classical RPG and hexagon tiles are pretty common for maps in that context.","title":"Hexagon Game Update: The Past"},{"content":"Well there\u0026rsquo;s been a little bit more progress on world generation. I\u0026rsquo;ve been avoiding working on roads (I have a theory) and rivers (lol no ideas), and doing \u0026ldquo;city\u0026rdquo; generation.\nPlacing the cities is easy enough. The world is divided into biomes, and we assign one city to each biome, checking to make sure when we place it there are no other cities too close. We also check against a reserved starting area.\nThe biggest problem is then names. These have to be sourced on demand from .. something. The best way would be names which were generated as needed, that were vaguely consistent with a language (ie, \u0026ldquo;hhhhhhhf\u0026rdquo; is not a great city name) and which didn\u0026rsquo;t just come from a fixed list (because I am not that creative).\nOne way would be to just use any one of a number of online generators to produce a \u0026ldquo;long enough\u0026rdquo; list for the game, and I did think about doing this. It wouldn\u0026rsquo;t be as elegant as actual name generation on the fly, but it\u0026rsquo;s simple to implement.\nAlthough \u0026ldquo;simple to implement\u0026rdquo; is often my approach1, there were some open source name generators based on a very classical approach called Markov Chains. These produce new \u0026ldquo;words\u0026rdquo; by statistical analysis of some input word lists and then making new combinations from the observed patterns in the lists plus some randomness.\nThere wasn\u0026rsquo;t any good examples I liked in GDscript, so porting one from another language was the next best thing. Despite how awful I am usually at writing code, I read it fairly well and have read enough in a variety of languages to be able to work out how to translate it to another language.\nOne of the biggest problems with doing that sort of porting is the actual algorithm can be opaque enough that the translation is merely shifting one language\u0026rsquo;s syntax to another syntax and a little bit of massaging how it uses types and built-in functions.\nUsually these things don\u0026rsquo;t come with a nice set of tests to show the outcome of any function works as expected. This means when it doesn\u0026rsquo;t work, if you don\u0026rsquo;t know the algorithm it an be pretty hard to see where it\u0026rsquo;s going wrong.\nAfter a few days of headscratching, I did finally find the cause of the code not producing any useful words: substrings. In the original langauge, there\u0026rsquo;s a function substring() which obviously would map to substr() in GDscript: give me some part of the string.\nBut it turned out these two functions had different meanings for their inputs: In GDscript it\u0026rsquo;s substr(start,len) while the original langauge I was porting from used substring(start,end). It had another function, substr() as well which implemented the same handling as GDscript\u0026rsquo;s substr(). But this wasn\u0026rsquo;t obvious when I did my awful lazy conversion pass over the code.\nNever mind, now it works. We have cities with generated names and a way to generate names for lots of other things.\nAt some point I\u0026rsquo;ll publish the GDscript code under the same license as the original if anyone wants it. I wouldn\u0026rsquo;t trust it though!\nSome readers will be aware that in the past my view of \u0026ldquo;simple\u0026rdquo; has included just ignoring huge sections of RFCs because they are not \u0026ldquo;really\u0026rdquo; needed. That\u0026rsquo;s how simple I sometimes reach.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-10-12/","summary":"Well there\u0026rsquo;s been a little bit more progress on world generation. I\u0026rsquo;ve been avoiding working on roads (I have a theory) and rivers (lol no ideas), and doing \u0026ldquo;city\u0026rdquo; generation.\nPlacing the cities is easy enough. The world is divided into biomes, and we assign one city to each biome, checking to make sure when we place it there are no other cities too close. We also check against a reserved starting area.","title":"Hexagon Game: Update for 12 October 2022"},{"content":"What\u0026rsquo;s all this then? From time to time I get this idea I can and should write video games. Which usually doesn\u0026rsquo;t end well, but hey, it\u0026rsquo;s something which passes the time.\nThis round I\u0026rsquo;ve decided to go with a classic procedural RPG using hexagon tiles and a top-down perspective camera. I tried using an othrographic camera and yet again I ran into issues with how it was culling shapes close and far from the camera.\nPerspective works just fine with a narrow field of view, and everything is much easier to drive spatially with it. Orthographic camera just always ended in tears failing to understand how to move it well and keep stuff in view.\nAnyway, this one seems to be actually holding my attention, so at some point I will release .. bwhahaha who am I kidding. This may never see light of day, but we shall see.\nAt the moment it\u0026rsquo;s only running on PC because Reasons. The main one is that Godot 4.0 beta has broken Android support for certain GPUs in Android phones. It tries to set up fancy Variable Rate Shading which my potato of a phone does not like.\nI\u0026rsquo;ll post more screenshots when there\u0026rsquo;s more game to show!\n","permalink":"https://dave2.github.io/post/never-complete-games-hexagon/","summary":"What\u0026rsquo;s all this then? From time to time I get this idea I can and should write video games. Which usually doesn\u0026rsquo;t end well, but hey, it\u0026rsquo;s something which passes the time.\nThis round I\u0026rsquo;ve decided to go with a classic procedural RPG using hexagon tiles and a top-down perspective camera. I tried using an othrographic camera and yet again I ran into issues with how it was culling shapes close and far from the camera.","title":"Never Complete Games: Hexagon"},{"content":"What happened this time? Yep, I\u0026rsquo;ve gone and built yet another blog. This time I can\u0026rsquo;t be bothered hosting it on my own magic domain so for now it\u0026rsquo;s just in GitHub Pages.\nIt\u0026rsquo;s still Hugo? Yes, still based on Hugo. I have a real love for static site generation even if it\u0026rsquo;s sometimes a pain to work with. This time I\u0026rsquo;ve used some guide on using GH Actions to make this work, so I can just git push and stuff happens.\nI mean, it doesn\u0026rsquo;t help the content quality but it sure is pretty.\nContent theme? In the past I\u0026rsquo;ve tried to stick to a theme, like technology or whatever. I don\u0026rsquo;t think I\u0026rsquo;ll do that this time. It\u0026rsquo;ll be whatever I feel like rambling about with no good reason.\nThis is not that I have to put this here. These are my own views and not those of anyone else or any other organisation I may be associated with in any capacity blah blah.\nIt won\u0026rsquo;t stop someone having a go of course.\n","permalink":"https://dave2.github.io/post/wat-another-blog-again/","summary":"What happened this time? Yep, I\u0026rsquo;ve gone and built yet another blog. This time I can\u0026rsquo;t be bothered hosting it on my own magic domain so for now it\u0026rsquo;s just in GitHub Pages.\nIt\u0026rsquo;s still Hugo? Yes, still based on Hugo. I have a real love for static site generation even if it\u0026rsquo;s sometimes a pain to work with. This time I\u0026rsquo;ve used some guide on using GH Actions to make this work, so I can just git push and stuff happens.","title":"Wat Another Blog Again"}]