[{"content":"Lots since the last update, lets dive into it.\nRefactoring Outcome Refactoring all the road generation to use tile variants instead of laying a separate prefab on top was a Huge Success and was definitely the right approach.\nBaking the roads into the tile set took a while but it resulted in a much nicer implementation internally, as I took the chance to also drop object pooling.\nAn optimization I had done very early on was to push 3D tiles into a pool of pre-instantiated objects and pull them into the world as needed. This is fairly useful in most game engines, but actually in Godot it turns out it has no useful performance gain at all.\nIn Godot, the cost of .instantiate() is basically nothing and you get a much cleaner code path without involving your own object pool. You can just create objects and then .queue_free() them when done. The name of that function hints at what is going on under the hood, and something I hadn\u0026rsquo;t really noticed until I did the refactor.\nSo long as you\u0026rsquo;ve already loaded the resource, the cost of spawning many new ones at once is as low as all the work needed to maintain the object pool. Having an object pool adds huge complexity (mostly on the freeing side, you can\u0026rsquo;t just free the object, you need to \u0026ldquo;hand back\u0026rdquo; the object to the pool). Given all the extra complexity with no performance gain, it was a good thing to remove it entirely and write more simple code.\nStalling Having refactored all code around the map view and in turn the way we load tile type information, it was time to revisit world generation, but specifically about both how slow it ran and the lack of feedback.\nProviding feedback to the user is really important. If you\u0026rsquo;re given a blank screen with no visible activity, the instinct is the game has crashed or is otherwise misbehaving, and to kill it. It\u0026rsquo;s important while doing heavy work to show work being done, and ideally some indication about the progress of that work.\nOkay, no worries, Godot has progress bars and text I can display for such things. But despite sending updates to the progress bars and text, nothing rendered until it was all done.\nThe immediate approach I took was to slice off the world generation into a thread and then just wait around for that to complete. This sort of worked and then I changed things and it didn\u0026rsquo;t, and because I\u0026rsquo;m not the smartest person I couldn\u0026rsquo;t remember what was actually changed which made any difference.\nGodot supports threads, and all the supporting elements needed to make threads word (like mutexes and semaphores). Alas, adding all these in various places didn\u0026rsquo;t make the code behave any better. In one part of the code, we\u0026rsquo;d test if the thread was running and it would always return false, while the output showed the thread clearly still running and spamming the log with messages.\nIt also didn\u0026rsquo;t help that it started to look like sometimes if you called functions they actually somehow caused all the visual rendering to stall even if that function should have been in a thread.. right?\nTwo days later, I now have a better understanding of both Godot\u0026rsquo;s main loop and most of the downsides of threads. Not a fun two days.\nOne thing I had forgotten is by and large games are single-threaded. They might offload certain low level functions to a thread, like audio playing or physics, but many games (and game engines) are single threaded because there are less complications about data access and synchronization than a multi-threaded game or engine.\nIn Godot\u0026rsquo;s case, rendering and _ready() in a script share a thread, so if you block in _ready() then rendering ain\u0026rsquo;t going to work. But, I had \u0026ldquo;solved\u0026rdquo; this with making sure world gen was on a thread.\nWell, sort of. Yes, some of it was on a thread, but not all of it, and it was hard to identify what was actually executing where. A lot of print-as-debug was added with every line including the output of OS.get_thread_caller_id to show where this was really taking place.\nWhat I found was it looks like singletons in Godot always execute on the main thread, and the way to avoid this is ensure any functions you call are on separate objects in your thread. Okay, refactor around that a bit (the calls into the world map singleton are fast, so we\u0026rsquo;ll ignore they run in the main thread, but it meant world gen had to be separated from the singleton).\nStill, we had problems, threads were being reported to the main code as finished when the logs were full of signs they were running. Getting to the bottom of this I think came down to pure luck and writing a separate set of tests in a different Godot project.\nThe test case I wrote looked something like the following. Note in this example we have a script on a node called SimpleProgressBar which updates different elements, like upper and lower text messages as well as the bar itself.\nvar progress_bar : Node var m : Mutex func _ready(): # we\u0026#39;ll use a progress bar for visuals progress_bar = get_node(\u0026#34;SimpleProgressBar\u0026#34;) # we\u0026#39;ll use this to protect our access m = Mutex.new() # start the long work thread var t = Thread.new() t.start(Callable(self,\u0026#34;_long_work_thread\u0026#34;)) for i in range(0,100): # update the progress bar too! m.lock() progress_bar.set_progress(i) m.unlock() await get_tree().create_timer(1).timeout # wait for the thread to exist while t.is_alive(): await get_tree().create_timer(1).timeout # clean up thread (normally blocks unless thread is dead) t.wait_until_finished() func _long_work_thread(): for i in range(0,100): # update the progress bar, ensuring no-one else is m.lock() progress_bar.set_lower_text(\u0026#34;Long process step %d\u0026#34; % i) m.unlock() # simulate a long process OS.delay_msec(5000) Okay, so the test case worked, even though I was sure I was doing the same thing in my game code. The long work thread continues to update the progress bar and this visually updates, and the code in _ready() waits for the long work thread to complete. It turns out, I wasn\u0026rsquo;t, and the detail is interesting.\nThe use of await in _ready() is because we don\u0026rsquo;t want to block, we know that we can\u0026rsquo;t call OS.delay_msec() because it would block and then rendering would stop. In the thread, we can just block (after all, that\u0026rsquo;s the point of the thread), so we call OS.delay_msec().\nGoing back over my game code, surely it doesn\u0026rsquo;t matter in a thread if we block or not, the thread is separate and we can do what we like. Oh, no, we definitely can\u0026rsquo;t.\nLet\u0026rsquo;s use a non-blocking delay instead in the long work thread, change OS.delay_msec(5000) to await get_tree().create_timer(5).timeout which is the same 5 second delay. Suddenly now the main code in _ready doesn\u0026rsquo;t wait for the thread to finish, it just plows through having been told from the result of t.is_alive() that the thread is dead.\nIt appears that you cannot call await in a thread other than the main thread. For whatever reason, the thread is lost and forgotten and you can\u0026rsquo;t get back to it. It is not the case that creating a thread gives you the same properties as the main thread at all.\nThe reason this tripped me up is that I was also doing some fancy fades using tweens to the progress bar. The common way to write this (and comes up in all the searches BTW) is:\nvar tween = create_tween() tween.tween_property(progress_bar, \u0026#34;modulate:a\u0026#34;, 1.0, 1.0) await t.finished So naturally, in my thread for doing long work, it started with that exact fragment. And then the thread blew up.\nIn fact, in the main loop we can do that, but we must block if we want to do that in a thread, and it becomes:\nvar tween = create_tween() tween.tween_property(progress_bar, \u0026#34;modulate:a\u0026#34;, 1.0, 1.0) while tween.is_running(): OS.delay_msec(100) Annoyingly, this also still causes rendering issues, but mostly it seems to be because OS.delay_msec() might just busy-loop and so it starves something else of cycles, so you get stuttering and uneven tweens.\nThe alternative to a thread for long work is our friend await and littering your long work with lots of calls to await get_tree().process_frame which will gracefully leave to allow rendering to continue for a whole frame, and then come back. This is pretty much how a single-threaded game should be doing things, but it certainly feels rough to write.\nAnyway, that\u0026rsquo;s two days I won\u0026rsquo;t get back.\nI\u0026rsquo;m unsure if I\u0026rsquo;ll revert out of threads for things like world gen, or leave it there. Now it has no problems with unexplained \u0026ldquo;death\u0026rdquo; it works so I\u0026rsquo;m tempted not to touch that whole space for a while.\nPerformance was also problematic for generating the world (even in a nice thread). There were quite a few cases where I was using a Dictionary for performance and then throwing that all away by forcing GDscript to iterate over an Array, which is a lot slower.\nFor example, here\u0026rsquo;s a few of ways of testing if we have something:\nvar big_thing : Dictionary() # ... if big_thing.has(\u0026#34;key\u0026#34;): # ... if \u0026#34;key\u0026#34; in big_thing: # ... if \u0026#34;key\u0026#34; in big_thing.keys() # ... The first is obviously using the dictionary correctly. The second and third I thought were the same, because of the in operator. This is not the case: using in with a Dictionary is functionally the same as calling .has() on it, while using in with the result of .keys() of the Dictionary produces an Array and then uses the in operator on it which is really really slow.\nI\u0026rsquo;ve been mixing all three types without much care, and it actually matters a lot. I still randomly pick between x.has(key) and key in x which isn\u0026rsquo;t so good, but for now at least they both don\u0026rsquo;t suck.\nThis alone was responsible for a large amount of lost time in world generation.\nSaving and Loading After the fun with threads, I got on with actually useful progress (ha ha) and implemented saving and loading the game state. This is mostly easy, and apart from not clearing out some state when loading, it just works.\nSave games are packed binary files, because serialization to say JSON is kind of annoying. Lots of types you have to munge and can\u0026rsquo;t just call JSON.stringify() on a wodge of data. Instead you have to pick out and transform some things to strings before trying to throw them into JSON.\nIt\u0026rsquo;s not that stringify() can\u0026rsquo;t convert some types to strings, it does that just fine. It\u0026rsquo;s that the inverse function, parse() doesn\u0026rsquo;t understand how to reverse stringify() for all cases.\nTake a Vector2, the string version is something like \u0026quot;(1.0, 2.0)\u0026quot;, which is just fine, it\u0026rsquo;s what JSON.stringify() produces, it\u0026rsquo;s valid JSON so all good. However, parse() just sees that as a string and gives you back .. a string. Fair enough, it is a string, but it\u0026rsquo;s a string you \u0026ndash; Mr JSON class \u0026ndash; put there. You want to give me back what I put into you? \u0026ldquo;Hell no\u0026rdquo; says Mr JSON class.\nThankfully, compared to the threading stuff, that\u0026rsquo;s easy to deal with. Don\u0026rsquo;t use JSON for save games.\nNext up Because I can\u0026rsquo;t leave well enough alone, I\u0026rsquo;m exploring a different tile set to the one currently being used. It has some nice features, like hexagons are more obviously visible, and a lot of interesting decorations for tiles.\nWhile playing around with a different tile set, it\u0026rsquo;s also become clear I am not handling materials on tiles in a way that makes it a bit easier for me to tweak the tile colouring and surface. So we\u0026rsquo;ll also be fixing that for the tile sets as well.\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-10-25/","summary":"Lots since the last update, lets dive into it.\nRefactoring Outcome Refactoring all the road generation to use tile variants instead of laying a separate prefab on top was a Huge Success and was definitely the right approach.\nBaking the roads into the tile set took a while but it resulted in a much nicer implementation internally, as I took the chance to also drop object pooling.\nAn optimization I had done very early on was to push 3D tiles into a pool of pre-instantiated objects and pull them into the world as needed.","title":"Hexagon Update: 25 Oct 2022"},{"content":" So I am now deep in the refactor well, and I\u0026rsquo;m pretty sure I can eventually get myself out, but right now everything is broken until I get to the bottom of the well, and start digging my way up.\nWhat triggered this was supporting roads. In the picture I posted on the last update there was a lovely road going through the gap in the forest. But there wasn\u0026rsquo;t a gap there really.\nThe road pieces can be spawned on top of any tile, and that\u0026rsquo;s how it looks like it could be used, but then you can\u0026rsquo;t really use them on any tile which has other things on it. That is, it works on the plain flat tiles, but not say a forest tile. On a forest tile, you get a look of a road which has trees all over it.\nTo work around that did a quick hack to just force the tile to one of the plain flat ones when a road gets created on a tile that isn\u0026rsquo;t so well designed for roads. Thus, the picture of the road going through the gap in forest is really the road mowing down all the forest tiles in its way on the shortest bit of forest to cross.\nI didn\u0026rsquo;t really like that, a road piece that neatly weaved through a forest closely would be nicer. And nicer becomes \u0026ldquo;let\u0026rsquo;s refactor the entire world\u0026rdquo;.\nThe upside is the tiles will look better when done, and at the same time I have half an idea of how to manage water traversal as well. It\u0026rsquo;ll involve less objects in the world as well.\nI have progressively integrated the road pieces, in some cases recolouring them, into the base tiles and adjusted the decorations on those tiles to allow the road piece to fit in, and then collected it all into a new tile - original base tile plus road piece - so they can be spawned at once.\nThis is mostly some work in Blender, since the tiles are all easily messed with in Blender. Using Blender falls into that slightly annoying tool space where KiCAD lives in my head as well. It\u0026rsquo;s one of those tools where knowing the keyboard actions really matters and without that you will struggle to do anything quickly at all.\nAnyway, that bit is done, I have many more tiles than I had before, and the ugly code and metadata reorganisation has begun.\nI\u0026rsquo;ll surface in a few days to report why I shouldn\u0026rsquo;t have done this.\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-10-21/","summary":"So I am now deep in the refactor well, and I\u0026rsquo;m pretty sure I can eventually get myself out, but right now everything is broken until I get to the bottom of the well, and start digging my way up.\nWhat triggered this was supporting roads. In the picture I posted on the last update there was a lovely road going through the gap in the forest. But there wasn\u0026rsquo;t a gap there really.","title":"Hexagon Update: Oh no"},{"content":"Well, it wouldn\u0026rsquo;t be my code development if any design pattern lasted longer than four hours! In fact, in the previous post it omits the details this was actually the second pass, where we stored masks in the tile data directly, rather than in a different set of dictionaries.\nBut, before tackling changing everything again, I did get to a better place about how to draw roads on the map. Not the display part now, the actual \u0026ldquo;draw road from A to B\u0026rdquo; including all the steps needed to join them.\nPathfinding is a well trodden area in game design. There\u0026rsquo;s a bunch of methods, but the A* algorithm fits my needs pretty well. This involves building a graph of nodes connected by edges, and assigning weights or costs or whatever you want to call it to traversing the node or edge.\nI was thinking I might have to build A* myself in GDscript but what\u0026rsquo;s this? Oh, Godot already includes A* classes to do all the work for me. Well, most of the work anyway, the traversal bit anyway. In Godot 4 we actually get three different versions of A*, mostly separated by the node elements.\nBecause we\u0026rsquo;re doing pathfinding on a 2D plane1 we\u0026rsquo;ll use the AStar2D class for our pathfinding. This provides two virtual methods we will need to replace, _compute_cost() and _estimate_cost() which given two points returns the exact or lower-bound cost of the path between the two points.\nWe have to overide those as we want our costs based on axial coordinate distances, not cartesian coordinates for the tiles themselves. And the AStar2D wants nodes with cartesian coordinates (specifically, it expects Vector2 coordinates). I should point out, this is noted in the Red Blog Games Hexagon Guide about Pathfinding, and is not something I\u0026rsquo;ve pulled out of skill or knowledge myself!\nAs we have a grid of tiles (albeit a hexagon grid), we\u0026rsquo;ll just throw a graph containing a node for every tile, and connections from each node to all neighbours that meet appropriate criteria (mostly, can put a road on it!)\nAt this point, the current implementation and the one I want to move to changes a bit. I\u0026rsquo;ve added costs to the metadata about tile types, as we\u0026rsquo;re applying something simple as a policy: tiles like grass are easy to move on, tiles like forests and mountains are harder but not impossible, and water should be impossible .. for now.\nI am making forests and mountains hard but not impossible to produce roads that tend to avoid these obstacles rather than plow through them, but will plow through them when there\u0026rsquo;s little choice but to make a very large detour around them. I think this will produce a pleasing balance between direct straight line roads and roads which have nice natural curves and meandering.\nAs it happens, building the graph the AStar2D class needs is remarkably easy. When we create a new tile (using the badly named set_tile()) we generate the point index the graph wants and store it with the tile. Then in update_tile() (which gets called either directly or by set_tile()) we add/update the point in the graph with the cost of that type of tile. This means when we change tiles we also update the costs in the graph of the tile.\nHowever, we also need to maintain the graph, so we do this in update_tile() as well. We also need to remove the point if the tile is no longer navigable, and connect or disconnect points in the graph as well. For connecting and disconnecting points, we walk our neighbours and check if they are appropriate to move into, and then add these appropriate connections.\nIn psuedo-code, for each tile we update it looks like:\nif updating tile: if tile_type is allowed road: add/update this point in graph for each neighbour: if neighbour is allowed road: add connection between this tile and neighbour tile else: remove connection between this tile and neighbour tile else: for each neighbour: remove connection between this tile and neighbour tile remove point from graph Once we have the graph with nodes, we can ask it for the path between two points. Because the AStar2D class expects point indexes, there\u0026rsquo;s a bunch of translation back and forth between axial coordinates of tiles and the point index. But, that\u0026rsquo;s fairly quick and thus we have roads which look more natural:\nI said there were things I wanted to change, and in writing this down plus the development issues, I think it will be reworked a bit very shortly.\nThe first problem is that as road pieces are expected to sit on a tile, they clash with some tiles. Forests, for example, don\u0026rsquo;t really look so good with a road going through them because the trees on the tile look like they\u0026rsquo;re on the road. To work around that, the current version just forces the tile to grass if it was forest before.\nThe other problem is water. Water is currently not allowed for traversal. It makes no sense, it\u0026rsquo;s a road, not a boat. How this is going to be managed is uncertain, but it\u0026rsquo;ll have to be some how. The map may end up with a slice of water dividing it in two and without any way of generating a road between the two sides.\nBut these are problems for another day.\nThe world is a flat plane even if we were to jazz it up a bit with tiles at different heights. That is, the player can\u0026rsquo;t decide to go up or down within a tile, they can only go to whatever height the tile is. So all our positions are 2D, thus navigation is on a 2D plane.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-10-18/","summary":"Well, it wouldn\u0026rsquo;t be my code development if any design pattern lasted longer than four hours! In fact, in the previous post it omits the details this was actually the second pass, where we stored masks in the tile data directly, rather than in a different set of dictionaries.\nBut, before tackling changing everything again, I did get to a better place about how to draw roads on the map. Not the display part now, the actual \u0026ldquo;draw road from A to B\u0026rdquo; including all the steps needed to join them.","title":"Hexagon Update: Roads .. again"},{"content":"As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.\nThe first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can\u0026rsquo;t see them. Also, I expect I\u0026rsquo;ll need to do extensive debugging on road generation and so I\u0026rsquo;ll also need to see them.\nThe tileset I\u0026rsquo;m using1 has roads as separate models to be added to the base tiles. The models cover all possible exit positions and combinations, although they have been normalised so some combinations and positions require rotating the model.\nYou can see the road tiles towards the bottom left corner of the image above (taken from Kenney.nl\u0026rsquo;s website).\nFor all of the tiles I\u0026rsquo;m using, I load these into the game based on some metadata about the tile, using a simple JSON file containing a list of the tiles and their metadata. For example, on the main tile set I have a metadata index containing:\n{ \u0026#34;water\u0026#34;: { \u0026#34;prefab_file\u0026#34;: \u0026#34;Tiles/water.glb\u0026#34;, \u0026#34;tags\u0026#34;: [ \u0026#34;water\u0026#34; ] }, \u0026#34;grass\u0026#34;: { \u0026#34;prefab_file\u0026#34;: \u0026#34;Tiles/grass.glb\u0026#34;, \u0026#34;tags\u0026#34;: [ \u0026#34;grass\u0026#34; ] } } (Aside: we actually read the metadata first and call load() on the prefab_file specified here, which gives us scenes to instance into the world. Everything is loaded into a Dictionary for easy access.)\nThe same approach is taken with road tiles, where we annotate what exits a given road piece has:\n[ { \u0026#34;exits\u0026#34;: [ \u0026#34;right\u0026#34;, \u0026#34;left\u0026#34; ], \u0026#34;prefab_file\u0026#34;: \u0026#34;Roads/path_straight.glb\u0026#34; }, { \u0026#34;exits\u0026#34;: [ \u0026#34;right\u0026#34; ], \u0026#34;prefab_file\u0026#34;: \u0026#34;Roads/path_start.glb\u0026#34; } ] As mentioned above, each road piece needs to be rotated to produce all of the possible combinations. The path_straight.glb piece has two other rotations available, 60 degrees should give us exits of [ \u0026quot;up_right\u0026quot;, \u0026quot;down_left\u0026quot; ], and 120 should give us [ \u0026quot;down_right\u0026quot;, \u0026quot;up_left\u0026quot; ]. (Probably, I haven\u0026rsquo;t checked this is correct!)\nIn the first pass of this code, I just wrote out the combinations by hand, adding a \u0026quot;rotation\u0026quot; field to the metadata. But I quickly found this was cumbersome, more so when I got the exits for a given rotation wrong (usually 0 degrees, so everything from there was wrong!). Instead, we produce all of the other possible exit positions for a road piece by iterating over the six different possible rotations and rotating the exits at the same time.\nAt this point, it\u0026rsquo;s useful to talk about how I resolve a tile having a specific list of exits to a road piece. We need to ignore the order the exits were provided in, and we need a fast way to look it up.\nThe naive implementation would be to stick all the exit combinations into an array that points to the tile/rotation needed. Then we walk over every element in the array of combinations, and then on each combination (itself an array) we compare it to the array of exits we have.\nThis is slow, we\u0026rsquo;re walking all possible combinations, and then also doing a bunch of array walks and then string compares to compare the exit arrays. Now, maybe this is premature, but there are faster ways to do this.\nInstead of storing the possible exits as an array of strings, we convert them to a bitfield. This has a few advantages:\nIt reduces the exits to a fixed order, regardless of how they appear in the metadata Bitfields are trivial to compare, they end up just as an int Using an int as a Dictionary key is fast and reliable Rotating the exits is very easy in a bitfield Now some of my younger readers will be wondering why on earth I would go deep into integer math to do this. Well, my programming roots include a great deal of C (that\u0026rsquo;s C, not C++, not C#) on microcontrollers, and that space is all about bitfields. And one thing you learn quickly in that space is when you have very few cycles, bitfields are very efficient at solving a bunch of problems.\nDuring import of the road pieces, we convert the exits array for a piece into a bitfield. We do this by assigning a bit to each exit, and the order of the bits corospond to going around the possible rotations. In sort of psuedocode, we do this:\nstr_to_mask = { \u0026#34;right\u0026#34;: 0x1, \u0026#34;up_right\u0026#34;: 0x2, \u0026#34;up_left\u0026#34;: 0x4, \u0026#34;left\u0026#34;: 0x8, \u0026#34;down_left\u0026#34;: 0x10, \u0026#34;down_right\u0026#34;: 0x20 } function exits_to_mask(exit_array) -\u0026gt; int mask = 0 for exit in exit_array: mask = mask | dirs_to_mask[exit] return mask The magic numbers are just the hexadecimal value of each bit being set (and only that bit).\nWhen stashing the road tile, we then use the mask for the key in the Dictionary, which will be a trivial lookup. (Aside: nearly $O(1)$ if you really want to know.)\nI said above that rotation is easy as well. If we\u0026rsquo;ve got an array of strings, we can\u0026rsquo;t just move the array contents around, we have to map each exit to the exit rotated one step around. The map is not slow itself (we can just have another lookup table), but in addition to all the string comparisons in the lookup table we need to walk all the exit array members.\nInstead, with the bitfield approach, we can rely on bit-shift operations to do the rotation, with a small bit of work to manage roll-over. Bit-shifting is often implemented in pure hardware, so it is reasonably efficient. Rotating the exit list each item is then just:\nfunction rotate_exits(mask) -\u0026gt; int # shift all the exits along mask = mask \u0026lt;\u0026lt; 1 # pass the rollover bit to the bottom mask = mask | (mask \u0026amp; 0x40 \u0026gt;\u0026gt; 5) # only keep the bits we\u0026#39;re interested in mask = mask \u0026amp; 0x3f # and return it return mask (Aside: most calculator apps will have a programmer mode that includes bit-shift and logical operations, which will show why this works.)\nGiven this, it\u0026rsquo;s fast to generate all the other road exit combinations for a given road piece, and to look up what piece we need for any combination.\nFor storage of road information, we mark tiles as having a road, and store the bitfield of exits. Adding a new road exit is purely doing a bit-wise OR on that exit in the tile. We also need to adjust the neighbour tile to reflect the connection back, but this is also a bit-wise OR.\nThis reduces our display effort to something very easy, just pull the road bitfield, look up that value in the index of all road pieces that are index by bitfield, and spawn the object in the correct place and rotation.\nEasy!\nKenney.nl Hexagon Kit\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-10-17/","summary":"As I mentioned in some previous update I have been avoiding roads, although I have some theories on how to make these work.\nThe first part of this however is just making roads appear in the game world. The generation of roads is a bit pointless if I can\u0026rsquo;t see them. Also, I expect I\u0026rsquo;ll need to do extensive debugging on road generation and so I\u0026rsquo;ll also need to see them.","title":"Hexagon Update: Roads"},{"content":"I realised that since I started writing this silly wee game I actually haven\u0026rsquo;t written down any of the initial thoughts about how this was goign to work, and since I\u0026rsquo;ve only just resurrected writing a blog after I\u0026rsquo;d already started writing the game there\u0026rsquo;s no history here either.\nRight, let\u0026rsquo;s see about writing some of those thoughts down.\nHexagon tiles I\u0026rsquo;m implementing a classical RPG and hexagon tiles are pretty common for maps in that context. Square maps are also an option, but I feel like they lend themselves better to worlds where you and the party are in fine-definition worlds, where hexagons are better at coarse-definition worlds.\nSo for example, in a fine-definition world a city or a village is a large number of tiles, you have the city\u0026rsquo;s streets to actually navigate around etc. In a coarse-definition world the city is one tile, possibly with some visual sugar around that, but internal city views are a bit more menu-like and less navigated using tiles.\nThis does also make some types of generation of the world a bit easier, because we really only looking at high-level detail and that has a lot fewer elements to try to model. Cities are just a single world position and not a complex map of tiles within the world.\nThat said, there\u0026rsquo;s nothing stopping me from implementing a nested world approach - where entering a city essentially creates a new hexagon map at a finer level of detail - so we\u0026rsquo;re not really closing ourselves off on doing that level of detail. It would always be a scene switch to do it, however.\nSince I\u0026rsquo;m pretty rubbish at art, I\u0026rsquo;m leaning into Kenney\u0026amp;rsquo;s Assets which include a Hexagon Tile Kit. So we have enough art to do world generation and some idea what the tile set should be able to do, if I can write the supporting code. If you have an interest in game dev but not much ability in art, then you really should look at Kenney\u0026rsquo;s work as it\u0026rsquo;s high quality and available under very generous license terms.\nThe tile set is flexible enough to be coarse or fine-definition, for the most part. There\u0026rsquo;s some gaps here and there but for this game in this state the gaps are just small workarounds.\nHexagon math Having a set of actual 3D tiles is all very well but you have to position them. The positioning is some very well documented math, the resource I used is Red Blob Games Hexagonal Grids which is extremely clearly written and easily implemented in any language you like. I\u0026rsquo;m not going to explain any of the math here!\nThe discussion on co-ordinate systems in Red Blob Games\u0026rsquo;s guide is very important to read before going to far into the development. I settled on the Axial coordinate system described in the guide.\nI didn\u0026rsquo;t consider the offset coordinate systems desscribed there for long because the math is annoying for neighbours, directions, distances etc. They were easiest to deal with by converting offset to cube or axial coordinates and if that\u0026rsquo;s the case I might as well use cube or axial natively.\nComparing axial to cube, the big advantage of axial is that the coordinates are always valid, as they are in offset systems. That is, a random value for each coordinate dimension is always okay, but with cube coordinates valid coordinates are only where they sum to zero.\nSince the vector math for axial is nothing unusual, we can use Godot\u0026rsquo;s Vector2i type for an axial coordinate. I\u0026rsquo;m using Vector3i for cube coordinates and there\u0026rsquo;s conversion functions between them documented in the Red Blob Games guide.\nThe conversion from axial to world (ie, where we place a hex on a flat plane) is also in the guide and is easy to implement. That makes positioning in the game\u0026rsquo;s 3D world coordinate space quick to do.\nCamera Hexagon tile games are commonly seen with both perspective cameras and orthographic cameras. The difference between the two is something you are best just firing at a search engine, but the tldr is perspective is what we see normally (far away objects are smaller), and ortographic keeps everything the same size regardless of distance.\nThe latter camera has the same look as games that use a 2D engine with tiles that fake 3Dness, the classic \u0026ldquo;isometric\u0026rdquo; look. That particular look is historically very common for an RPG or tile base game.\nAlthough it\u0026rsquo;s tempting to ram home the somewhat retro ideas in the game by using an isometric (or approximately isometric) view, I\u0026rsquo;ve ended up using a perspective camera as I have had endless problems with Godot\u0026rsquo;s orthographic camera, ranging from clipping models to annoying lighting behaviour.\nI know that there\u0026rsquo;s a big chunk of this which is just my understanding of how to correctly configure and drive the camera, but perspective \u0026ldquo;Just Works\u0026rdquo; and it\u0026rsquo;s perfectly valid for a tile RPG (or other hexagonal grid games, like Civilization), so I\u0026rsquo;m taking the path of least resistance.\nHexagon storage The Red Blob Games guide to Hexagon grids discusses some issues around storage, but this is actually a pretty easy decision.\nSince Godot provides Dictionary type, and we can use axial coordinates (really Vector2i) as keys, it is the fastest and easiest way to store the map data. It will tolerate any shape and holes or partially generated state. It has fast access since it uses a hash to return the content of a specific key, it enforces unique keys, and walking the whole map is no harder than any other storage approach. It stores about as efficiently as is possible.\nAs I\u0026rsquo;m using axial coordinates, there are helper functions to do things like return the neighours of a coordinate, or the tile in a specific direction and distance, and so forth. We don\u0026rsquo;t rely on the data storage structure to provide those constructs, so it doesn\u0026rsquo;t matter that the storage has no concept of these.\nHowever, there\u0026rsquo;s one issue with storage of a world..\nInfinite vs Finite I am a fan of infinite prodcedural worlds. But for this game, I don\u0026rsquo;t think we need a world we move infinitely in any direction, as we can provide new generated challenges within a finite world.\nNot allowing the world to be infinite has several benefits. For one, world generation is simplier if the world is finite, as we can simply iterate over the world multiple times to add features to it. With infinite worlds, each area or chunk (generally) needs to be generated independently and unexpectedly.\nThe other comes with approaching difficulty for the player. Rather than having the difficulty determined by some value proportionate to experience or gear, I would like difficulty to be determined by the location the player is at.\nThat is, difficulty is a function of the distance from a \u0026ldquo;safe\u0026rdquo; point to the edge of the world. For easy implementation, we\u0026rsquo;ll set the safe point to the literal center of the world (Vector2i(0,0)). This means when the player travels far away from the center the challenges are more difficult, but they can easily control what challenges they want to manage just by moving around.\nWith an infinite world, you can do this, but I feel like it takes away from one of the values of an infinite world (that is, you can just \u0026ldquo;explore\u0026rdquo; and you aren\u0026rsquo;t bound to the same place, but you can\u0026rsquo;t if the difficulty gets worse the further you are out).\nAt the same time, I can hand-wave away the storage of the world needing chunks because we don\u0026rsquo;t need chunks straight away for a finite world. Let\u0026rsquo;s just make the whole world sit in RAM. What could go wrong?\nWraping up Thus, the game being written is:\nA finite world, so we can cut corners on world gen Difficulty scales by distance from the centre, in which case we can just use a \u0026ldquo;circular\u0026rdquo; (actually big hexagon) shape for the world Perspective because Orthogonal camera disagrees with me Doesn\u0026rsquo;t yet try to do anything to load/save/cache chunks but just has everything in memory at once There\u0026rsquo;s other decisions yet to come, but this\u0026rsquo;ll do for now.\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-10-13/","summary":"I realised that since I started writing this silly wee game I actually haven\u0026rsquo;t written down any of the initial thoughts about how this was goign to work, and since I\u0026rsquo;ve only just resurrected writing a blog after I\u0026rsquo;d already started writing the game there\u0026rsquo;s no history here either.\nRight, let\u0026rsquo;s see about writing some of those thoughts down.\nHexagon tiles I\u0026rsquo;m implementing a classical RPG and hexagon tiles are pretty common for maps in that context.","title":"Hexagon Game Update: The Past"},{"content":"Well there\u0026rsquo;s been a little bit more progress on world generation. I\u0026rsquo;ve been avoiding working on roads (I have a theory) and rivers (lol no ideas), and doing \u0026ldquo;city\u0026rdquo; generation.\nPlacing the cities is easy enough. The world is divided into biomes, and we assign one city to each biome, checking to make sure when we place it there are no other cities too close. We also check against a reserved starting area.\nThe biggest problem is then names. These have to be sourced on demand from .. something. The best way would be names which were generated as needed, that were vaguely consistent with a language (ie, \u0026ldquo;hhhhhhhf\u0026rdquo; is not a great city name) and which didn\u0026rsquo;t just come from a fixed list (because I am not that creative).\nOne way would be to just use any one of a number of online generators to produce a \u0026ldquo;long enough\u0026rdquo; list for the game, and I did think about doing this. It wouldn\u0026rsquo;t be as elegant as actual name generation on the fly, but it\u0026rsquo;s simple to implement.\nAlthough \u0026ldquo;simple to implement\u0026rdquo; is often my approach1, there were some open source name generators based on a very classical approach called Markov Chains. These produce new \u0026ldquo;words\u0026rdquo; by statistical analysis of some input word lists and then making new combinations from the observed patterns in the lists plus some randomness.\nThere wasn\u0026rsquo;t any good examples I liked in GDscript, so porting one from another language was the next best thing. Despite how awful I am usually at writing code, I read it fairly well and have read enough in a variety of languages to be able to work out how to translate it to another language.\nOne of the biggest problems with doing that sort of porting is the actual algorithm can be opaque enough that the translation is merely shifting one language\u0026rsquo;s syntax to another syntax and a little bit of massaging how it uses types and built-in functions.\nUsually these things don\u0026rsquo;t come with a nice set of tests to show the outcome of any function works as expected. This means when it doesn\u0026rsquo;t work, if you don\u0026rsquo;t know the algorithm it an be pretty hard to see where it\u0026rsquo;s going wrong.\nAfter a few days of headscratching, I did finally find the cause of the code not producing any useful words: substrings. In the original langauge, there\u0026rsquo;s a function substring() which obviously would map to substr() in GDscript: give me some part of the string.\nBut it turned out these two functions had different meanings for their inputs: In GDscript it\u0026rsquo;s substr(start,len) while the original langauge I was porting from used substring(start,end). It had another function, substr() as well which implemented the same handling as GDscript\u0026rsquo;s substr(). But this wasn\u0026rsquo;t obvious when I did my awful lazy conversion pass over the code.\nNever mind, now it works. We have cities with generated names and a way to generate names for lots of other things.\nAt some point I\u0026rsquo;ll publish the GDscript code under the same license as the original if anyone wants it. I wouldn\u0026rsquo;t trust it though!\nSome readers will be aware that in the past my view of \u0026ldquo;simple\u0026rdquo; has included just ignoring huge sections of RFCs because they are not \u0026ldquo;really\u0026rdquo; needed. That\u0026rsquo;s how simple I sometimes reach.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://dave2.github.io/post/hexagon-update-2022-10-12/","summary":"Well there\u0026rsquo;s been a little bit more progress on world generation. I\u0026rsquo;ve been avoiding working on roads (I have a theory) and rivers (lol no ideas), and doing \u0026ldquo;city\u0026rdquo; generation.\nPlacing the cities is easy enough. The world is divided into biomes, and we assign one city to each biome, checking to make sure when we place it there are no other cities too close. We also check against a reserved starting area.","title":"Hexagon Game: Update for 12 October 2022"},{"content":"What\u0026rsquo;s all this then? From time to time I get this idea I can and should write video games. Which usually doesn\u0026rsquo;t end well, but hey, it\u0026rsquo;s something which passes the time.\nThis round I\u0026rsquo;ve decided to go with a classic procedural RPG using hexagon tiles and a top-down perspective camera. I tried using an othrographic camera and yet again I ran into issues with how it was culling shapes close and far from the camera.\nPerspective works just fine with a narrow field of view, and everything is much easier to drive spatially with it. Orthographic camera just always ended in tears failing to understand how to move it well and keep stuff in view.\nAnyway, this one seems to be actually holding my attention, so at some point I will release .. bwhahaha who am I kidding. This may never see light of day, but we shall see.\nAt the moment it\u0026rsquo;s only running on PC because Reasons. The main one is that Godot 4.0 beta has broken Android support for certain GPUs in Android phones. It tries to set up fancy Variable Rate Shading which my potato of a phone does not like.\nI\u0026rsquo;ll post more screenshots when there\u0026rsquo;s more game to show!\n","permalink":"https://dave2.github.io/post/never-complete-games-hexagon/","summary":"What\u0026rsquo;s all this then? From time to time I get this idea I can and should write video games. Which usually doesn\u0026rsquo;t end well, but hey, it\u0026rsquo;s something which passes the time.\nThis round I\u0026rsquo;ve decided to go with a classic procedural RPG using hexagon tiles and a top-down perspective camera. I tried using an othrographic camera and yet again I ran into issues with how it was culling shapes close and far from the camera.","title":"Never Complete Games: Hexagon"},{"content":"What happened this time? Yep, I\u0026rsquo;ve gone and built yet another blog. This time I can\u0026rsquo;t be bothered hosting it on my own magic domain so for now it\u0026rsquo;s just in GitHub Pages.\nIt\u0026rsquo;s still Hugo? Yes, still based on Hugo. I have a real love for static site generation even if it\u0026rsquo;s sometimes a pain to work with. This time I\u0026rsquo;ve used some guide on using GH Actions to make this work, so I can just git push and stuff happens.\nI mean, it doesn\u0026rsquo;t help the content quality but it sure is pretty.\nContent theme? In the past I\u0026rsquo;ve tried to stick to a theme, like technology or whatever. I don\u0026rsquo;t think I\u0026rsquo;ll do that this time. It\u0026rsquo;ll be whatever I feel like rambling about with no good reason.\nThis is not that I have to put this here. These are my own views and not those of anyone else or any other organisation I may be associated with in any capacity blah blah.\nIt won\u0026rsquo;t stop someone having a go of course.\n","permalink":"https://dave2.github.io/post/wat-another-blog-again/","summary":"What happened this time? Yep, I\u0026rsquo;ve gone and built yet another blog. This time I can\u0026rsquo;t be bothered hosting it on my own magic domain so for now it\u0026rsquo;s just in GitHub Pages.\nIt\u0026rsquo;s still Hugo? Yes, still based on Hugo. I have a real love for static site generation even if it\u0026rsquo;s sometimes a pain to work with. This time I\u0026rsquo;ve used some guide on using GH Actions to make this work, so I can just git push and stuff happens.","title":"Wat Another Blog Again"}]